"use strict"; (self.webpackChunkfylo_landing_page_with_two_column_layout = self.webpackChunkfylo_landing_page_with_two_column_layout || []).push([[179], { 417: () => { function oe(e) { return "function" == typeof e } function fo(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const ho = fo(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function cr(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class pt { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const i of n) i.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (oe(r)) try { r() } catch (i) { t = i instanceof ho ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { Vu(i) } catch (s) { t = t ?? [], s instanceof ho ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new ho(t) } } add(t) { var n; if (t && t !== this) if (this.closed) Vu(t); else { if (t instanceof pt) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && cr(n, t) } remove(t) { const { _finalizers: n } = this; n && cr(n, t), t instanceof pt && t._removeParent(this) } } pt.EMPTY = (() => { const e = new pt; return e.closed = !0, e })(); const ku = pt.EMPTY; function Lu(e) { return e instanceof pt || e && "closed" in e && oe(e.remove) && oe(e.add) && oe(e.unsubscribe) } function Vu(e) { oe(e) ? e() : e.unsubscribe() } const rn = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, po = { setTimeout(e, t, ...n) { const { delegate: r } = po; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { const { delegate: t } = po; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function Bu(e) { po.setTimeout(() => { const { onUnhandledError: t } = rn; if (!t) throw e; t(e) }) } function ju() { } const Vy = ts("C", void 0, void 0); function ts(e, t, n) { return { kind: e, value: t, error: n } } let on = null; function go(e) { if (rn.useDeprecatedSynchronousErrorHandling) { const t = !on; if (t && (on = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = on; if (on = null, n) throw r } } else e() } class ns extends pt { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, Lu(t) && t.add(this)) : this.destination = zy } static create(t, n, r) { return new dr(t, n, r) } next(t) { this.isStopped ? os(function jy(e) { return ts("N", e, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? os(function By(e) { return ts("E", void 0, e) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? os(Vy, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const $y = Function.prototype.bind; function rs(e, t) { return $y.call(e, t) } class Uy { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { mo(r) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { mo(r) } else mo(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { mo(n) } } } class dr extends ns { constructor(t, n, r) { let o; if (super(), oe(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && rn.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && rs(t.next, i), error: t.error && rs(t.error, i), complete: t.complete && rs(t.complete, i) }) : o = t } this.destination = new Uy(o) } } function mo(e) { rn.useDeprecatedSynchronousErrorHandling ? function Hy(e) { rn.useDeprecatedSynchronousErrorHandling && on && (on.errorThrown = !0, on.error = e) }(e) : Bu(e) } function os(e, t) { const { onStoppedNotification: n } = rn; n && po.setTimeout(() => n(e, t)) } const zy = { closed: !0, next: ju, error: function Gy(e) { throw e }, complete: ju }, is = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Hu(e) { return e } let Ne = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { const i = function qy(e) { return e && e instanceof ns || function Wy(e) { return e && oe(e.next) && oe(e.error) && oe(e.complete) }(e) && Lu(e) }(n) ? n : new dr(n, r, o); return go(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = Uu(r))((o, i) => { const s = new dr({ next: a => { try { n(a) } catch (l) { i(l), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [is]() { return this } pipe(...n) { return function $u(e) { return 0 === e.length ? Hu : 1 === e.length ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } }(n)(this) } toPromise(n) { return new (n = Uu(n))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function Uu(e) { var t; return null !== (t = e ?? rn.Promise) && void 0 !== t ? t : Promise } const Zy = fo(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let ss = (() => { class e extends Ne { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new Gu(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new Zy } next(n) { go(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { go(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { go(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? ku : (this.currentObservers = null, i.push(n), new pt(() => { this.currentObservers = null, cr(i, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { const n = new Ne; return n.source = this, n } } return e.create = (t, n) => new Gu(t, n), e })(); class Gu extends ss { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : ku } } function fr(e) { return t => { if (function Yy(e) { return oe(e?.lift) }(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function hr(e, t, n, r, o) { return new Qy(e, t, n, r, o) } class Qy extends ns { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (l) { t.error(l) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (l) { t.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function as(e, t) { return fr((n, r) => { let o = 0; n.subscribe(hr(r, i => { r.next(e.call(t, i, o++)) })) }) } function Gt(e) { return this instanceof Gt ? (this.v = e, this) : new Gt(e) } function Zu(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function ds(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, l) { !function o(i, s, a, l) { Promise.resolve(l).then(function (u) { i({ value: u, done: a }) }, s) }(a, l, (s = e[i](s)).done, s.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const Yu = e => e && "number" == typeof e.length && "function" != typeof e; function Qu(e) { return oe(e?.then) } function Ku(e) { return oe(e[is]) } function Xu(e) { return Symbol.asyncIterator && oe(e?.[Symbol.asyncIterator]) } function Ju(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const ec = function DD() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function tc(e) { return oe(e?.[ec]) } function nc(e) { return function qu(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = n.apply(e, t || []), i = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { r[f] && (o[f] = function (h) { return new Promise(function (p, g) { i.push([f, h, p, g]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function l(f) { f.value instanceof Gt ? Promise.resolve(f.value.v).then(u, c) : d(i[0][2], f) }(r[f](h)) } catch (p) { d(i[0][3], p) } } function u(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), i.shift(), i.length && a(i[0][0], i[0][1]) } }(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield Gt(n.read()); if (o) return yield Gt(void 0); yield yield Gt(r) } } finally { n.releaseLock() } }) } function rc(e) { return oe(e?.getReader) } function It(e) { if (e instanceof Ne) return e; if (null != e) { if (Ku(e)) return function vD(e) { return new Ne(t => { const n = e[is](); if (oe(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (Yu(e)) return function _D(e) { return new Ne(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (Qu(e)) return function CD(e) { return new Ne(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, Bu) }) }(e); if (Xu(e)) return oc(e); if (tc(e)) return function wD(e) { return new Ne(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (rc(e)) return function ED(e) { return oc(nc(e)) }(e) } throw Ju(e) } function oc(e) { return new Ne(t => { (function bD(e, t) { var n, r, o, i; return function zu(e, t, n, r) { return new (n || (n = Promise))(function (i, s) { function a(c) { try { u(r.next(c)) } catch (d) { s(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { s(d) } } function u(c) { c.done ? i(c.value) : function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) }(c.value).then(a, l) } u((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = Zu(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function zt(e, t, n, r = 0, o = !1) { const i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function ic(e, t, n = 1 / 0) { return oe(t) ? ic((r, o) => as((i, s) => t(r, i, o, s))(It(e(r, o))), n) : ("number" == typeof t && (n = t), fr((r, o) => function MD(e, t, n, r, o, i, s, a) { const l = []; let u = 0, c = 0, d = !1; const f = () => { d && !l.length && !u && t.complete() }, h = g => u < r ? p(g) : l.push(g), p = g => { i && t.next(g), u++; let D = !1; It(n(g, c++)).subscribe(hr(t, v => { o?.(v), i ? h(v) : t.next(v) }, () => { D = !0 }, void 0, () => { if (D) try { for (u--; l.length && u < r;) { const v = l.shift(); s ? zt(t, s, () => p(v)) : p(v) } f() } catch (v) { t.error(v) } })) }; return e.subscribe(hr(t, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, n))) } const sc = new Ne(e => e.complete()); function fs(e) { return e[e.length - 1] } function ac(e, t = 0) { return fr((n, r) => { n.subscribe(hr(r, o => zt(r, e, () => r.next(o), t), () => zt(r, e, () => r.complete(), t), o => zt(r, e, () => r.error(o), t))) }) } function lc(e, t = 0) { return fr((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function uc(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new Ne(n => { zt(n, t, () => { const r = e[Symbol.asyncIterator](); zt(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function cc(e, t) { return t ? function LD(e, t) { if (null != e) { if (Ku(e)) return function xD(e, t) { return It(e).pipe(lc(t), ac(t)) }(e, t); if (Yu(e)) return function PD(e, t) { return new Ne(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (Qu(e)) return function OD(e, t) { return It(e).pipe(lc(t), ac(t)) }(e, t); if (Xu(e)) return uc(e, t); if (tc(e)) return function RD(e, t) { return new Ne(n => { let r; return zt(n, t, () => { r = e[ec](), zt(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void n.error(s) } i ? n.complete() : n.next(o) }, 0, !0) }), () => oe(r?.return) && r.return() }) }(e, t); if (rc(e)) return function kD(e, t) { return uc(nc(e), t) }(e, t) } throw Ju(e) }(e, t) : It(e) } function VD(...e) { const t = function FD(e) { return function AD(e) { return e && oe(e.schedule) }(fs(e)) ? e.pop() : void 0 }(e), n = function ND(e, t) { return "number" == typeof fs(e) ? e.pop() : t }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? It(r[0]) : function ID(e = 1 / 0) { return ic(Hu, e) }(n)(cc(r, t)) : sc } function hs(e, t, ...n) { if (!0 === t) return void e(); if (!1 === t) return; const r = new dr({ next: () => { r.unsubscribe(), e() } }); return It(t(...n)).subscribe(r) } function Q(e) { for (let t in e) if (e[t] === Q) return t; throw Error("Could not find renamed property on target object.") } function ps(e, t) { for (const n in t) t.hasOwnProperty(n) && !e.hasOwnProperty(n) && (e[n] = t[n]) } function K(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(K).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function gs(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const jD = Q({ __forward_ref__: Q }); function X(e) { return e.__forward_ref__ = X, e.toString = function () { return K(this()) }, e } function S(e) { return ms(e) ? e() : e } function ms(e) { return "function" == typeof e && e.hasOwnProperty(jD) && e.__forward_ref__ === X } function ys(e) { return e && !!e.\u0275providers } class C extends Error { constructor(t, n) { super(yo(t, n)), this.code = t } } function yo(e, t) { return `NG0${Math.abs(e)}${t ? ": " + t.trim() : ""}` } function N(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function Do(e, t) { throw new C(-201, !1) } function Qe(e, t) { null == e && function W(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function ee(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function St(e) { return { providers: e.providers || [], imports: e.imports || [] } } function vo(e) { return fc(e, _o) || fc(e, pc) } function fc(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function hc(e) { return e && (e.hasOwnProperty(Ds) || e.hasOwnProperty(qD)) ? e[Ds] : null } const _o = Q({ \u0275prov: Q }), Ds = Q({ \u0275inj: Q }), pc = Q({ ngInjectableDef: Q }), qD = Q({ ngInjectorDef: Q }); var T = (() => ((T = T || {})[T.Default = 0] = "Default", T[T.Host = 1] = "Host", T[T.Self = 2] = "Self", T[T.SkipSelf = 4] = "SkipSelf", T[T.Optional = 8] = "Optional", T))(); let vs; function Ke(e) { const t = vs; return vs = e, t } function gc(e, t, n) { const r = vo(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & T.Optional ? null : void 0 !== t ? t : void Do(K(e)) } const te = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), pr = {}, _s = "__NG_DI_FLAG__", Co = "ngTempTokenPath", YD = "ngTokenPath", QD = /\n/gm, KD = "\u0275", mc = "__source"; let gr; function Cn(e) { const t = gr; return gr = e, t } function XD(e, t = T.Default) { if (void 0 === gr) throw new C(-203, !1); return null === gr ? gc(e, void 0, t) : gr.get(e, t & T.Optional ? null : void 0, t) } function $(e, t = T.Default) { return (function ZD() { return vs }() || XD)(S(e), t) } function wo(e) { return typeof e > "u" || "number" == typeof e ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function Cs(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = S(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new C(900, !1); let o, i = T.Default; for (let s = 0; s < r.length; s++) { const a = r[s], l = JD(a); "number" == typeof l ? -1 === l ? o = a.token : i |= l : o = a } t.push($(o, i)) } else t.push($(r)) } return t } function mr(e, t) { return e[_s] = t, e.prototype[_s] = t, e } function JD(e) { return e[_s] } function At(e) { return { toString: e }.toString() } var gt = (() => ((gt = gt || {})[gt.OnPush = 0] = "OnPush", gt[gt.Default = 1] = "Default", gt))(), mt = (() => { return (e = mt || (mt = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", mt; var e })(); const Tt = {}, U = [], Eo = Q({ \u0275cmp: Q }), ws = Q({ \u0275dir: Q }), Es = Q({ \u0275pipe: Q }), vc = Q({ \u0275mod: Q }), Ft = Q({ \u0275fac: Q }), yr = Q({ __NG_ELEMENT_ID__: Q }); let nv = 0; function sn(e) { return At(() => { const t = Cc(e), n = { ...t, decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === gt.OnPush, directiveDefs: null, pipeDefs: null, dependencies: t.standalone && e.dependencies || null, getStandaloneInjector: null, data: e.data || {}, encapsulation: e.encapsulation || mt.Emulated, id: "c" + nv++, styles: e.styles || U, _: null, schemas: e.schemas || null, tView: null }; wc(n); const r = e.dependencies; return n.directiveDefs = bo(r, !1), n.pipeDefs = bo(r, !0), n }) } function ov(e) { return q(e) || Ce(e) } function iv(e) { return null !== e } function qt(e) { return At(() => ({ type: e.type, bootstrap: e.bootstrap || U, declarations: e.declarations || U, imports: e.imports || U, exports: e.exports || U, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function _c(e, t) { if (null == e) return Tt; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), n[o] = r, t && (t[o] = i) } return n } function x(e) { return At(() => { const t = Cc(e); return wc(t), t }) } function q(e) { return e[Eo] || null } function Ce(e) { return e[ws] || null } function Be(e) { return e[Es] || null } function Cc(e) { const t = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: t, exportAs: e.exportAs || null, standalone: !0 === e.standalone, selectors: e.selectors || U, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: _c(e.inputs, t), outputs: _c(e.outputs) } } function wc(e) { e.features?.forEach(t => t(e)) } function bo(e, t) { if (!e) return null; const n = t ? Be : ov; return () => ("function" == typeof e ? e() : e).map(r => n(r)).filter(iv) } const Nt = 0, E = 1, R = 2, ae = 3, rt = 4, an = 5, we = 6, wn = 7, ue = 8, Mo = 9, Io = 10, L = 11, bs = 12, vr = 13, Ec = 14, En = 15, Ee = 16, _r = 17, bn = 18, yt = 19, Cr = 20, bc = 21, ne = 22, Ms = 1, Mc = 2, So = 7, Ao = 8, Mn = 9, xe = 10; function We(e) { return Array.isArray(e) && "object" == typeof e[Ms] } function ot(e) { return Array.isArray(e) && !0 === e[Ms] } function Is(e) { return 0 != (4 & e.flags) } function wr(e) { return e.componentOffset > -1 } function To(e) { return 1 == (1 & e.flags) } function it(e) { return !!e.template } function av(e) { return 0 != (256 & e[R]) } function ln(e, t) { return e.hasOwnProperty(Ft) ? e[Ft] : null } class cv { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function xt() { return Ac } function Ac(e) { return e.type.prototype.ngOnChanges && (e.setInput = fv), dv } function dv() { const e = Fc(this), t = e?.current; if (t) { const n = e.previous; if (n === Tt) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function fv(e, t, n, r) { const o = this.declaredInputs[n], i = Fc(e) || function hv(e, t) { return e[Tc] = t }(e, { previous: Tt, current: null }), s = i.current || (i.current = {}), a = i.previous, l = a[o]; s[o] = new cv(l && l.currentValue, t, a === Tt), e[r] = t } xt.ngInherit = !0; const Tc = "__ngSimpleChanges__"; function Fc(e) { return e[Tc] || null } const Xe = function (e, t, n) { }; function ve(e) { for (; Array.isArray(e);)e = e[Nt]; return e } function qe(e, t) { return ve(t[e.index]) } function Oc(e, t) { return e.data[t] } function je(e, t) { const n = t[e]; return We(n) ? n : n[Nt] } function No(e) { return 64 == (64 & e[R]) } function Zt(e, t) { return null == t ? null : e[t] } function Pc(e) { e[bn] = 0 } function As(e, t) { e[an] += t; let n = e, r = e[ae]; for (; null !== r && (1 === t && 1 === n[an] || -1 === t && 0 === n[an]);)r[an] += t, n = r, r = r[ae] } const O = { lFrame: Gc(null), bindingsEnabled: !0 }; function kc() { return O.bindingsEnabled } function y() { return O.lFrame.lView } function H() { return O.lFrame.tView } function _e() { let e = Lc(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function Lc() { return O.lFrame.currentTNode } function Dt(e, t) { const n = O.lFrame; n.currentTNode = e, n.isParent = t } function Ts() { return O.lFrame.isParent } function Sn() { return O.lFrame.bindingIndex++ } function Av(e, t) { const n = O.lFrame; n.bindingIndex = n.bindingRootIndex = e, Ns(t) } function Ns(e) { O.lFrame.currentDirectiveIndex = e } function Os(e) { O.lFrame.currentQueryIndex = e } function Fv(e) { const t = e[E]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[we] : null } function $c(e, t, n) { if (n & T.SkipSelf) { let o = t, i = e; for (; !(o = o.parent, null !== o || n & T.Host || (o = Fv(i), null === o || (i = i[En], 10 & o.type)));); if (null === o) return !1; t = o, e = i } const r = O.lFrame = Uc(); return r.currentTNode = t, r.lView = e, !0 } function Ps(e) { const t = Uc(), n = e[E]; O.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function Uc() { const e = O.lFrame, t = null === e ? null : e.child; return null === t ? Gc(e) : t } function Gc(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function zc() { const e = O.lFrame; return O.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const Wc = zc; function Rs() { const e = zc(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function Pe() { return O.lFrame.selectedIndex } function un(e) { O.lFrame.selectedIndex = e } function ie() { const e = O.lFrame; return Oc(e.tView, e.selectedIndex) } function xo(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: u, ngOnDestroy: c } = i; s && (e.contentHooks ?? (e.contentHooks = [])).push(-n, s), a && ((e.contentHooks ?? (e.contentHooks = [])).push(n, a), (e.contentCheckHooks ?? (e.contentCheckHooks = [])).push(n, a)), l && (e.viewHooks ?? (e.viewHooks = [])).push(-n, l), u && ((e.viewHooks ?? (e.viewHooks = [])).push(n, u), (e.viewCheckHooks ?? (e.viewCheckHooks = [])).push(n, u)), null != c && (e.destroyHooks ?? (e.destroyHooks = [])).push(n, c) } } function Oo(e, t, n) { qc(e, t, 3, n) } function Po(e, t, n, r) { (3 & e[R]) === n && qc(e, t, n, r) } function ks(e, t) { let n = e[R]; (3 & n) === t && (n &= 2047, n += 1, e[R] = n) } function qc(e, t, n, r) { const i = r ?? -1, s = t.length - 1; let a = 0; for (let l = void 0 !== r ? 65535 & e[bn] : 0; l < s; l++)if ("number" == typeof t[l + 1]) { if (a = t[l], null != r && a >= r) break } else t[l] < 0 && (e[bn] += 65536), (a < i || -1 == i) && (Bv(e, n, t, l), e[bn] = (4294901760 & e[bn]) + l + 2), l++ } function Bv(e, t, n, r) { const o = n[r] < 0, i = n[r + 1], a = e[o ? -n[r] : n[r]]; if (o) { if (e[R] >> 11 < e[bn] >> 16 && (3 & e[R]) === t) { e[R] += 2048, Xe(4, a, i); try { i.call(a) } finally { Xe(5, a, i) } } } else { Xe(4, a, i); try { i.call(a) } finally { Xe(5, a, i) } } } const An = -1; class br { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function Vs(e, t, n) { let r = 0; for (; r < n.length;) { const o = n[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { const i = o, s = n[++r]; Yc(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function Zc(e) { return 3 === e || 4 === e || 6 === e } function Yc(e) { return 64 === e.charCodeAt(0) } function Mr(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const o = t[r]; "number" == typeof o ? n = o : 0 === n || Qc(e, n, o, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function Qc(e, t, n, r, o) { let i = 0, s = e.length; if (-1 === t) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } function Kc(e) { return e !== An } function Ro(e) { return 32767 & e } function ko(e, t) { let n = function Uv(e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[En], n--; return r } let Bs = !0; function Lo(e) { const t = Bs; return Bs = e, t } const Xc = 255, Jc = 5; let Gv = 0; const vt = {}; function Vo(e, t) { const n = ed(e, t); if (-1 !== n) return n; const r = t[E]; r.firstCreatePass && (e.injectorIndex = t.length, js(r.data, e), js(t, null), js(r.blueprint, null)); const o = Hs(e, t), i = e.injectorIndex; if (Kc(o)) { const s = Ro(o), a = ko(o, t), l = a[E].data; for (let u = 0; u < 8; u++)t[i + u] = a[s + u] | l[s + u] } return t[i + 8] = o, i } function js(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function ed(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function Hs(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; null !== o;) { if (r = ad(o), null === r) return An; if (n++, o = o[En], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return An } function $s(e, t, n) { !function zv(e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(yr) && (r = n[yr]), null == r && (r = n[yr] = Gv++); const o = r & Xc; t.data[e + (o >> Jc)] |= 1 << o }(e, t, n) } function td(e, t, n) { if (n & T.Optional || void 0 !== e) return e; Do() } function nd(e, t, n, r) { if (n & T.Optional && void 0 === r && (r = null), !(n & (T.Self | T.Host))) { const o = e[Mo], i = Ke(void 0); try { return o ? o.get(t, r, n & T.Optional) : gc(t, r, n & T.Optional) } finally { Ke(i) } } return td(r, 0, n) } function rd(e, t, n, r = T.Default, o) { if (null !== e) { if (1024 & t[R]) { const s = function Qv(e, t, n, r, o) { let i = e, s = t; for (; null !== i && null !== s && 1024 & s[R] && !(256 & s[R]);) { const a = od(i, s, n, r | T.Self, vt); if (a !== vt) return a; let l = i.parent; if (!l) { const u = s[bc]; if (u) { const c = u.get(n, vt, r); if (c !== vt) return c } l = ad(s), s = s[En] } i = l } return o }(e, t, n, r, vt); if (s !== vt) return s } const i = od(e, t, n, r, vt); if (i !== vt) return i } return nd(t, n, r, o) } function od(e, t, n, r, o) { const i = function Zv(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(yr) ? e[yr] : void 0; return "number" == typeof t ? t >= 0 ? t & Xc : Yv : t }(n); if ("function" == typeof i) { if (!$c(t, e, r)) return r & T.Host ? td(o, 0, r) : nd(t, n, r, o); try { const s = i(r); if (null != s || r & T.Optional) return s; Do() } finally { Wc() } } else if ("number" == typeof i) { let s = null, a = ed(e, t), l = An, u = r & T.Host ? t[Ee][we] : null; for ((-1 === a || r & T.SkipSelf) && (l = -1 === a ? Hs(e, t) : t[a + 8], l !== An && sd(r, !1) ? (s = t[E], a = Ro(l), t = ko(l, t)) : a = -1); -1 !== a;) { const c = t[E]; if (id(i, a, c.data)) { const d = qv(a, t, n, s, r, u); if (d !== vt) return d } l = t[a + 8], l !== An && sd(r, t[E].data[a + 8] === u) && id(i, a, t) ? (s = c, a = Ro(l), t = ko(l, t)) : a = -1 } } return o } function qv(e, t, n, r, o, i) { const s = t[E], a = s.data[e + 8], c = function Bo(e, t, n, r, o) { const i = e.providerIndexes, s = t.data, a = 1048575 & i, l = e.directiveStart, c = i >> 20, f = o ? a + c : e.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = s[h]; if (h < l && n === p || h >= l && p.type === n) return h } if (o) { const h = s[l]; if (h && it(h) && h.type === n) return l } return null }(a, s, n, null == r ? wr(a) && Bs : r != s && 0 != (3 & a.type), o & T.Host && i === a); return null !== c ? cn(t, s, c, a) : vt } function cn(e, t, n, r) { let o = e[n]; const i = t.data; if (function jv(e) { return e instanceof br }(o)) { const s = o; s.resolving && function HD(e, t) { const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new C(-200, `Circular dependency in DI detected for ${e}${n}`) }(function z(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : N(e) }(i[n])); const a = Lo(s.canSeeViewProviders); s.resolving = !0; const l = s.injectImpl ? Ke(s.injectImpl) : null; $c(e, r, T.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function Vv(e, t, n) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { const s = Ac(t); (n.preOrderHooks ?? (n.preOrderHooks = [])).push(e, s), (n.preOrderCheckHooks ?? (n.preOrderCheckHooks = [])).push(e, s) } o && (n.preOrderHooks ?? (n.preOrderHooks = [])).push(0 - e, o), i && ((n.preOrderHooks ?? (n.preOrderHooks = [])).push(e, i), (n.preOrderCheckHooks ?? (n.preOrderCheckHooks = [])).push(e, i)) }(n, i[n], t) } finally { null !== l && Ke(l), Lo(a), s.resolving = !1, Wc() } } return o } function id(e, t, n) { return !!(n[t + (e >> Jc)] & 1 << e) } function sd(e, t) { return !(e & T.Self || e & T.Host && t) } class Tn { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return rd(this._tNode, this._lView, t, wo(r), n) } } function Yv() { return new Tn(_e(), y()) } function be(e) { return At(() => { const t = e.prototype.constructor, n = t[Ft] || Us(t), r = Object.prototype; let o = Object.getPrototypeOf(e.prototype).constructor; for (; o && o !== r;) { const i = o[Ft] || Us(o); if (i && i !== n) return i; o = Object.getPrototypeOf(o) } return i => new i }) } function Us(e) { return ms(e) ? () => { const t = Us(S(e)); return t && t() } : ln(e) } function ad(e) { const t = e[E], n = t.type; return 2 === n ? t.declTNode : 1 === n ? e[we] : null } const Nn = "__parameters__"; function On(e, t, n) { return At(() => { const r = function zs(e) { return function (...n) { if (e) { const r = e(...n); for (const o in r) this[o] = r[o] } } }(t); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(l, u, c) { const d = l.hasOwnProperty(Nn) ? l[Nn] : Object.defineProperty(l, Nn, { value: [] })[Nn]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(s), l } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } class F { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = ee({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function dn(e, t) { e.forEach(n => Array.isArray(n) ? dn(n, t) : t(n)) } function ud(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function jo(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } function Ze(e, t, n) { let r = Pn(e, t); return r >= 0 ? e[1 | r] = n : (r = ~r, function e_(e, t, n, r) { let o = e.length; if (o == t) e.push(n, r); else if (1 === o) e.push(r, e[0]), e[0] = n; else { for (o--, e.push(e[o - 1], e[o]); o > t;)e[o] = e[o - 2], o--; e[t] = n, e[t + 1] = r } }(e, r, t, n)), r } function qs(e, t) { const n = Pn(e, t); if (n >= 0) return e[1 | n] } function Pn(e, t) { return function cd(e, t, n) { let r = 0, o = e.length >> n; for (; o !== r;) { const i = r + (o - r >> 1), s = e[i << n]; if (t === s) return i << n; s > t ? o = i : r = i + 1 } return ~(o << n) }(e, t, 1) } const $o = mr(On("Optional"), 8), Uo = mr(On("SkipSelf"), 4); var He = (() => ((He = He || {})[He.Important = 1] = "Important", He[He.DashCase = 2] = "DashCase", He))(); const Js = new Map; let w_ = 0; const ta = "__ngContext__"; function Me(e, t) { We(t) ? (e[ta] = t[Cr], function b_(e) { Js.set(e[Cr], e) }(t)) : e[ta] = t } let na; function ra(e, t) { return na(e, t) } function xr(e) { const t = e[ae]; return ot(t) ? t[ae] : t } function oa(e) { return Fd(e[vr]) } function ia(e) { return Fd(e[rt]) } function Fd(e) { for (; null !== e && !ot(e);)e = e[rt]; return e } function kn(e, t, n, r, o) { if (null != r) { let i, s = !1; ot(r) ? i = r : We(r) && (s = !0, r = r[Nt]); const a = ve(r); 0 === e && null !== n ? null == o ? kd(t, n, a) : fn(t, n, a, o || null, !0) : 1 === e && null !== n ? fn(t, n, a, o || null, !0) : 2 === e ? function fa(e, t, n) { const r = Wo(e, t); r && function G_(e, t, n, r) { e.removeChild(t, n, r) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != i && function q_(e, t, n, r, o) { const i = n[So]; i !== ve(n) && kn(t, e, r, i, o); for (let a = xe; a < n.length; a++) { const l = n[a]; Or(l[E], l, e, t, r, i) } }(t, e, i, n, o) } } function aa(e, t, n) { return e.createElement(t, n) } function xd(e, t) { const n = e[Mn], r = n.indexOf(t), o = t[ae]; 512 & t[R] && (t[R] &= -513, As(o, -1)), n.splice(r, 1) } function la(e, t) { if (e.length <= xe) return; const n = xe + t, r = e[n]; if (r) { const o = r[_r]; null !== o && o !== e && xd(o, r), t > 0 && (e[n - 1][rt] = r[rt]); const i = jo(e, xe + t); !function k_(e, t) { Or(e, t, t[L], 2, null, null), t[Nt] = null, t[we] = null }(r[E], r); const s = i[yt]; null !== s && s.detachView(i[E]), r[ae] = null, r[rt] = null, r[R] &= -65 } return r } function Od(e, t) { if (!(128 & t[R])) { const n = t[L]; n.destroyNode && Or(e, t, n, 3, null, null), function B_(e) { let t = e[vr]; if (!t) return ua(e[E], e); for (; t;) { let n = null; if (We(t)) n = t[vr]; else { const r = t[xe]; r && (n = r) } if (!n) { for (; t && !t[rt] && t !== e;)We(t) && ua(t[E], t), t = t[ae]; null === t && (t = e), We(t) && ua(t[E], t), n = t && t[rt] } t = n } }(t) } } function ua(e, t) { if (!(128 & t[R])) { t[R] &= -65, t[R] |= 128, function U_(e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const o = t[n[r]]; if (!(o instanceof br)) { const i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], l = i[s + 1]; Xe(4, a, l); try { l.call(a) } finally { Xe(5, a, l) } } else { Xe(4, o, i); try { i.call(o) } finally { Xe(5, o, i) } } } } }(e, t), function $_(e, t) { const n = e.cleanup, r = t[wn]; let o = -1; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const s = n[i + 3]; s >= 0 ? r[o = s]() : r[o = -s].unsubscribe(), i += 2 } else { const s = r[o = n[i + 1]]; n[i].call(s) } if (null !== r) { for (let i = o + 1; i < r.length; i++)(0, r[i])(); t[wn] = null } }(e, t), 1 === t[E].type && t[L].destroy(); const n = t[_r]; if (null !== n && ot(t[ae])) { n !== t[ae] && xd(n, t); const r = t[yt]; null !== r && r.detachView(e) } !function M_(e) { Js.delete(e[Cr]) }(t) } } function Pd(e, t, n) { return function Rd(e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[Nt]; { const { componentOffset: o } = r; if (o > -1) { const { encapsulation: i } = e.data[r.directiveStart + o]; if (i === mt.None || i === mt.Emulated) return null } return qe(r, n) } }(e, t.parent, n) } function fn(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function kd(e, t, n) { e.appendChild(t, n) } function Ld(e, t, n, r, o) { null !== r ? fn(e, t, n, r, o) : kd(e, t, n) } function Wo(e, t) { return e.parentNode(t) } let ca, ga, jd = function Bd(e, t, n) { return 40 & e.type ? qe(e, n) : null }; function qo(e, t, n, r) { const o = Pd(e, r, t), i = t[L], a = function Vd(e, t, n) { return jd(e, t, n) }(r.parent || t[we], r, t); if (null != o) if (Array.isArray(n)) for (let l = 0; l < n.length; l++)Ld(i, o, n[l], a, !1); else Ld(i, o, n, a, !1); void 0 !== ca && ca(i, r, t, n, o) } function Zo(e, t) { if (null !== t) { const n = t.type; if (3 & n) return qe(t, e); if (4 & n) return da(-1, e[t.index]); if (8 & n) { const r = t.child; if (null !== r) return Zo(e, r); { const o = e[t.index]; return ot(o) ? da(-1, o) : ve(o) } } if (32 & n) return ra(t, e)() || ve(e[t.index]); { const r = $d(e, t); return null !== r ? Array.isArray(r) ? r[0] : Zo(xr(e[Ee]), r) : Zo(e, t.next) } } return null } function $d(e, t) { return null !== t ? e[Ee][we].projection[t.projection] : null } function da(e, t) { const n = xe + e + 1; if (n < t.length) { const r = t[n], o = r[E].firstChild; if (null !== o) return Zo(r, o) } return t[So] } function ha(e, t, n, r, o, i, s) { for (; null != n;) { const a = r[n.index], l = n.type; if (s && 0 === t && (a && Me(ve(a), r), n.flags |= 2), 32 != (32 & n.flags)) if (8 & l) ha(e, t, n.child, r, o, i, !1), kn(t, e, o, a, i); else if (32 & l) { const u = ra(n, r); let c; for (; c = u();)kn(t, e, o, c, i); kn(t, e, o, a, i) } else 16 & l ? Ud(e, t, r, n, o, i) : kn(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function Or(e, t, n, r, o, i) { ha(n, r, e.firstChild, t, o, i, !1) } function Ud(e, t, n, r, o, i) { const s = n[Ee], l = s[we].projection[r.projection]; if (Array.isArray(l)) for (let u = 0; u < l.length; u++)kn(t, e, o, l[u], i); else ha(e, t, l, s[ae], o, i, !0) } function Gd(e, t, n) { "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function zd(e, t, n) { const { mergedAttrs: r, classes: o, styles: i } = n; null !== r && Vs(e, t, r), null !== o && Gd(e, t, o), null !== i && function Y_(e, t, n) { e.setAttribute(t, "style", n) }(e, t, i) } class Qd { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } const sf = new F("ENVIRONMENT_INITIALIZER"), af = new F("INJECTOR", -1), lf = new F("INJECTOR_DEF_TYPES"); class uf { get(t, n = pr) { if (n === pr) { const r = new Error(`NullInjectorError: No provider for ${K(t)}!`); throw r.name = "NullInjectorError", r } return n } } function EC(...e) { return { \u0275providers: cf(0, e), \u0275fromNgModule: !0 } } function cf(e, ...t) { const n = [], r = new Set; let o; return dn(t, i => { const s = i; Ca(s, n, [], r) && (o || (o = []), o.push(s)) }), void 0 !== o && df(o, n), n } function df(e, t) { for (let n = 0; n < e.length; n++) { const { providers: o } = e[n]; wa(o, i => { t.push(i) }) } } function Ca(e, t, n, r) { if (!(e = S(e))) return !1; let o = null, i = hc(e); const s = !i && q(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const l = e.ngModule; if (i = hc(l), !i) return !1; o = l } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const l = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const u of l) Ca(u, t, n, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let u; r.add(o); try { dn(i.imports, c => { Ca(c, t, n, r) && (u || (u = []), u.push(c)) }) } finally { } void 0 !== u && df(u, t) } if (!a) { const u = ln(o) || (() => new o); t.push({ provide: o, useFactory: u, deps: U }, { provide: lf, useValue: o, multi: !0 }, { provide: sf, useValue: () => $(o), multi: !0 }) } const l = i.providers; null == l || a || wa(l, c => { t.push(c) }) } } return o !== e && void 0 !== e.providers } function wa(e, t) { for (let n of e) ys(n) && (n = n.\u0275providers), Array.isArray(n) ? wa(n, t) : t(n) } const bC = Q({ provide: String, useValue: Q }); function Ea(e) { return null !== e && "object" == typeof e && bC in e } function hn(e) { return "function" == typeof e } const ba = new F("Set Injector scope."), Xo = {}, IC = {}; let Ma; function Jo() { return void 0 === Ma && (Ma = new uf), Ma } class Vn { } class pf extends Vn { get destroyed() { return this._destroyed } constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Sa(t, s => this.processProvider(s)), this.records.set(af, Bn(void 0, this)), o.has("environment") && this.records.set(Vn, Bn(void 0, this)); const i = this.records.get(ba); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(lf.multi, U, T.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const t of this._ngOnDestroyHooks) t.ngOnDestroy(); for (const t of this._onDestroyHooks) t() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(t) { this._onDestroyHooks.push(t) } runInContext(t) { this.assertNotDestroyed(); const n = Cn(this), r = Ke(void 0); try { return t() } finally { Cn(n), Ke(r) } } get(t, n = pr, r = T.Default) { this.assertNotDestroyed(), r = wo(r); const o = Cn(this), i = Ke(void 0); try { if (!(r & T.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const l = function NC(e) { return "function" == typeof e || "object" == typeof e && e instanceof F }(t) && vo(t); a = l && this.injectableDefInScope(l) ? Bn(Ia(t), Xo) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (r & T.Self ? Jo() : this.parent).get(t, n = r & T.Optional && n === pr ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[Co] = s[Co] || []).unshift(K(t)), o) throw s; return function ev(e, t, n, r) { const o = e[Co]; throw t[mc] && o.unshift(t[mc]), e.message = function tv(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && e.charAt(1) == KD ? e.slice(2) : e; let o = K(t); if (Array.isArray(t)) o = t.map(K).join(" -> "); else if ("object" == typeof t) { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : K(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(QD, "\n  ")}` }("\n" + e.message, o, n, r), e[YD] = o, e[Co] = null, e }(s, t, "R3InjectorError", this.source) } throw s } finally { Ke(i), Cn(o) } } resolveInjectorInitializers() { const t = Cn(this), n = Ke(void 0); try { const r = this.get(sf.multi, U, T.Self); for (const o of r) o() } finally { Cn(t), Ke(n) } } toString() { const t = [], n = this.records; for (const r of n.keys()) t.push(K(r)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new C(205, !1) } processProvider(t) { let n = hn(t = S(t)) ? t : S(t && t.provide); const r = function AC(e) { return Ea(e) ? Bn(void 0, e.useValue) : Bn(gf(e), Xo) }(t); if (hn(t) || !0 !== t.multi) this.records.get(n); else { let o = this.records.get(n); o || (o = Bn(void 0, Xo, !0), o.factory = () => Cs(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n) { return n.value === Xo && (n.value = IC, n.value = n.factory()), "object" == typeof n.value && n.value && function FC(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = S(t.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } } function Ia(e) { const t = vo(e), n = null !== t ? t.factory : ln(e); if (null !== n) return n; if (e instanceof F) throw new C(204, !1); if (e instanceof Function) return function SC(e) { const t = e.length; if (t > 0) throw function Ar(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"), new C(204, !1); const n = function WD(e) { return e && (e[_o] || e[pc]) || null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new C(204, !1) } function gf(e, t, n) { let r; if (hn(e)) { const o = S(e); return ln(o) || Ia(o) } if (Ea(e)) r = () => S(e.useValue); else if (function hf(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...Cs(e.deps || [])); else if (function ff(e) { return !(!e || !e.useExisting) }(e)) r = () => $(S(e.useExisting)); else { const o = S(e && (e.useClass || e.provide)); if (!function TC(e) { return !!e.deps }(e)) return ln(o) || Ia(o); r = () => new o(...Cs(e.deps)) } return r } function Bn(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function Sa(e, t) { for (const n of e) Array.isArray(n) ? Sa(n, t) : n && ys(n) ? Sa(n.\u0275providers, t) : t(n) } class xC { } class mf { } class PC { resolveComponentFactory(t) { throw function OC(e) { const t = Error(`No component factory found for ${K(e)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = e, t }(t) } } let ei = (() => { class e { } return e.NULL = new PC, e })(); function RC() { return jn(_e(), y()) } function jn(e, t) { return new st(qe(e, t)) } let st = (() => { class e { constructor(n) { this.nativeElement = n } } return e.__NG_ELEMENT_ID__ = RC, e })(); class Df { } let pn = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => function LC() { const e = y(), n = je(_e().index, e); return (We(n) ? n : e)[L] }(), e })(), VC = (() => { class e { } return e.\u0275prov = ee({ token: e, providedIn: "root", factory: () => null }), e })(); class ti { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const BC = new ti("15.2.10"), Aa = {}, Ta = "ngOriginalError"; function Fa(e) { return e[Ta] } class Hn { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t); this._console.error("ERROR", t), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && Fa(t); for (; n && Fa(n);)n = Fa(n); return n || null } } function _f(e, t, n) { let r = e.length; for (; ;) { const o = e.indexOf(t, n); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } const Cf = "ng-template"; function QC(e, t, n) { let r = 0, o = !0; for (; r < e.length;) { let i = e[r++]; if ("string" == typeof i && o) { const s = e[r++]; if (n && "class" === i && -1 !== _f(s.toLowerCase(), t, 0)) return !0 } else { if (1 === i) { for (; r < e.length && "string" == typeof (i = e[r++]);)if (i.toLowerCase() === t) return !0; return !1 } "number" == typeof i && (o = !1) } } return !1 } function wf(e) { return 4 === e.type && e.value !== Cf } function KC(e, t, n) { return t === (4 !== e.type || n ? e.value : Cf) } function XC(e, t, n) { let r = 4; const o = e.attrs || [], i = function tw(e) { for (let t = 0; t < e.length; t++)if (Zc(e[t])) return t; return e.length }(o); let s = !1; for (let a = 0; a < t.length; a++) { const l = t[a]; if ("number" != typeof l) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !KC(e, l, n) || "" === l && 1 === t.length) { if (at(r)) return !1; s = !0 } } else { const u = 8 & r ? l : t[++a]; if (8 & r && null !== e.attrs) { if (!QC(e.attrs, u, n)) { if (at(r)) return !1; s = !0 } continue } const d = JC(8 & r ? "class" : l, o, wf(e), n); if (-1 === d) { if (at(r)) return !1; s = !0; continue } if ("" !== u) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== _f(h, u, 0) || 2 & r && u !== f) { if (at(r)) return !1; s = !0 } } } } else { if (!s && !at(r) && !at(l)) return !1; if (s && at(l)) continue; s = !1, r = l | 1 & r } } return at(r) || s } function at(e) { return 0 == (1 & e) } function JC(e, t, n, r) { if (null === t) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { const s = t[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = t[++o]; for (; "string" == typeof a;)a = t[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function nw(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function Ef(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (XC(e, t[r], n)) return !0; return !1 } function bf(e, t) { return e ? ":not(" + t.trim() + ")" : t } function ow(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !at(s) && (t += bf(i, o), o = ""), r = s, i = i || !at(r); n++ } return "" !== o && (t += bf(i, o)), t } const P = {}; function Lr(e) { Mf(H(), y(), Pe() + e, !1) } function Mf(e, t, n, r) { if (!r) if (3 == (3 & t[R])) { const i = e.preOrderCheckHooks; null !== i && Oo(t, i, n) } else { const i = e.preOrderHooks; null !== i && Po(t, i, 0, n) } un(n) } function Tf(e, t = null, n = null, r) { const o = Ff(e, t, n, r); return o.resolveInjectorInitializers(), o } function Ff(e, t = null, n = null, r, o = new Set) { const i = [n || U, EC(e)]; return r = r || ("object" == typeof e ? void 0 : K(e)), new pf(i, t || Jo(), r || null, o) } let Qt = (() => { class e { static create(n, r) { if (Array.isArray(n)) return Tf({ name: "" }, r, n, ""); { const o = n.name ?? ""; return Tf({ name: o }, n.parent, n.providers, o) } } } return e.THROW_IF_NOT_FOUND = pr, e.NULL = new uf, e.\u0275prov = ee({ token: e, providedIn: "any", factory: () => $(af) }), e.__NG_ELEMENT_ID__ = -1, e })(); function _(e, t = T.Default) { const n = y(); return null === n ? $(e, t) : rd(_e(), n, S(e), t) } function Lf(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r + 1]; if (-1 !== i) { const s = e.data[i]; Os(n[r]), s.contentQueries(2, t[i], i) } } } function ri(e, t, n, r, o, i, s, a, l, u, c) { const d = t.blueprint.slice(); return d[Nt] = o, d[R] = 76 | r, (null !== c || e && 1024 & e[R]) && (d[R] |= 1024), Pc(d), d[ae] = d[En] = e, d[ue] = n, d[Io] = s || e && e[Io], d[L] = a || e && e[L], d[bs] = l || e && e[bs] || null, d[Mo] = u || e && e[Mo] || null, d[we] = i, d[Cr] = function E_() { return w_++ }(), d[bc] = c, d[Ee] = 2 == t.type ? e[Ee] : d, d } function Gn(e, t, n, r, o) { let i = e.data[t]; if (null === i) i = function Ra(e, t, n, r, o) { const i = Lc(), s = Ts(), l = e.data[t] = function Nw(e, t, n, r, o, i) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, n, t, r, o); return null === e.firstChild && (e.firstChild = l), null !== i && (s ? null == i.child && null !== l.parent && (i.child = l) : null === i.next && (i.next = l, l.prev = i)), l }(e, t, n, r, o), function Sv() { return O.lFrame.inI18n }() && (i.flags |= 32); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = o; const s = function Er() { const e = O.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return Dt(i, !0), i } function Vr(e, t, n, r) { if (0 === n) return -1; const o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function ka(e, t, n) { Ps(t); try { const r = e.viewQuery; null !== r && za(1, r, n); const o = e.template; null !== o && Vf(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && Lf(e, t), e.staticViewQueries && za(2, e.viewQuery, n); const i = e.components; null !== i && function Aw(e, t) { for (let n = 0; n < t.length; n++)Kw(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[R] &= -5, Rs() } } function oi(e, t, n, r) { const o = t[R]; if (128 != (128 & o)) { Ps(t); try { Pc(t), function Bc(e) { return O.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && Vf(e, t, n, 2, r); const s = 3 == (3 & o); if (s) { const u = e.preOrderCheckHooks; null !== u && Oo(t, u, null) } else { const u = e.preOrderHooks; null !== u && Po(t, u, 0, null), ks(t, 0) } if (function Yw(e) { for (let t = oa(e); null !== t; t = ia(t)) { if (!t[Mc]) continue; const n = t[Mn]; for (let r = 0; r < n.length; r++) { const o = n[r]; 512 & o[R] || As(o[ae], 1), o[R] |= 512 } } }(t), function Zw(e) { for (let t = oa(e); null !== t; t = ia(t))for (let n = xe; n < t.length; n++) { const r = t[n], o = r[E]; No(r) && oi(o, r, o.template, r[ue]) } }(t), null !== e.contentQueries && Lf(e, t), s) { const u = e.contentCheckHooks; null !== u && Oo(t, u) } else { const u = e.contentHooks; null !== u && Po(t, u, 1), ks(t, 1) } !function Iw(e, t) { const n = e.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const o = n[r]; if (o < 0) un(~o); else { const i = o, s = n[++r], a = n[++r]; Av(s, i), a(2, t[i]) } } } finally { un(-1) } }(e, t); const a = e.components; null !== a && function Sw(e, t) { for (let n = 0; n < t.length; n++)Qw(e, t[n]) }(t, a); const l = e.viewQuery; if (null !== l && za(2, l, r), s) { const u = e.viewCheckHooks; null !== u && Oo(t, u) } else { const u = e.viewHooks; null !== u && Po(t, u, 2), ks(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), t[R] &= -41, 512 & t[R] && (t[R] &= -513, As(t[ae], -1)) } finally { Rs() } } } function Vf(e, t, n, r, o) { const i = Pe(), s = 2 & r; try { un(-1), s && t.length > ne && Mf(e, t, ne, !1), Xe(s ? 2 : 0, o), n(r, o) } finally { un(i), Xe(s ? 3 : 1, o) } } function La(e, t, n) { if (Is(t)) { const o = t.directiveEnd; for (let i = t.directiveStart; i < o; i++) { const s = e.data[i]; s.contentQueries && s.contentQueries(1, n[i], i) } } } function Va(e, t, n) { kc() && (function Vw(e, t, n, r) { const o = n.directiveStart, i = n.directiveEnd; wr(n) && function zw(e, t, n) { const r = qe(t, e), o = Bf(n), i = e[Io], s = ii(e, ri(e, o, null, n.onPush ? 32 : 16, r, t, i, i.createRenderer(r, n), null, null, null)); e[t.index] = s }(t, n, e.data[o + n.componentOffset]), e.firstCreatePass || Vo(n, t), Me(r, t); const s = n.initialInputs; for (let a = o; a < i; a++) { const l = e.data[a], u = cn(t, e, a, n); Me(u, t), null !== s && Ww(0, a - o, u, l, 0, s), it(l) && (je(n.index, t)[ue] = cn(t, e, a, n)) } }(e, t, n, qe(n, t)), 64 == (64 & n.flags) && Gf(e, t, n)) } function Ba(e, t, n = qe) { const r = t.localNames; if (null !== r) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? n(t, e) : e[s]; e[o++] = a } } } function Bf(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = ja(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : t } function ja(e, t, n, r, o, i, s, a, l, u) { const c = ne + r, d = c + o, f = function Tw(e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : P); return n }(c, d), h = "function" == typeof u ? u() : u; return f[E] = { type: e, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: t, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: l, consts: h, incompleteFirstPass: !1 } } function Hf(e, t, n, r) { for (let o in e) if (e.hasOwnProperty(o)) { n = null === n ? {} : n; const i = e[o]; null === r ? $f(n, t, o, i) : r.hasOwnProperty(o) && $f(n, t, r[o], i) } return n } function $f(e, t, n, r) { e.hasOwnProperty(n) ? e[n].push(t, r) : e[n] = [t, r] } function Ha(e, t, n, r) { if (kc()) { const o = null === r ? null : { "": -1 }, i = function jw(e, t) { const n = e.directiveRegistry; let r = null, o = null; if (n) for (let i = 0; i < n.length; i++) { const s = n[i]; if (Ef(t, s.selectors, !1)) if (r || (r = []), it(s)) if (null !== s.findHostDirectiveDefs) { const a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), r.unshift(...a, s), $a(e, t, a.length) } else r.unshift(s), $a(e, t, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, r, o), r.push(s) } return null === r ? null : [r, o] }(e, n); let s, a; null === i ? s = a = null : [s, a] = i, null !== s && Uf(e, t, n, s, o, a), o && function Hw(e, t, n) { if (t) { const r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { const i = n[t[o + 1]]; if (null == i) throw new C(-301, !1); r.push(t[o], i) } } }(n, r, o) } n.mergedAttrs = Mr(n.mergedAttrs, n.attrs) } function Uf(e, t, n, r, o, i) { for (let u = 0; u < r.length; u++)$s(Vo(n, t), e, r[u].type); !function Uw(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t }(n, e.data.length, r.length); for (let u = 0; u < r.length; u++) { const c = r[u]; c.providersResolver && c.providersResolver(c) } let s = !1, a = !1, l = Vr(e, t, r.length, null); for (let u = 0; u < r.length; u++) { const c = r[u]; n.mergedAttrs = Mr(n.mergedAttrs, c.hostAttrs), Gw(e, n, t, l, c), $w(l, c, o), null !== c.contentQueries && (n.flags |= 4), (null !== c.hostBindings || null !== c.hostAttrs || 0 !== c.hostVars) && (n.flags |= 64); const d = c.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks ?? (e.preOrderHooks = [])).push(n.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks ?? (e.preOrderCheckHooks = [])).push(n.index), a = !0), l++ } !function xw(e, t, n) { const o = t.directiveEnd, i = e.data, s = t.attrs, a = []; let l = null, u = null; for (let c = t.directiveStart; c < o; c++) { const d = i[c], f = n ? n.get(d) : null, p = f ? f.outputs : null; l = Hf(d.inputs, c, l, f ? f.inputs : null), u = Hf(d.outputs, c, u, p); const g = null === l || null === s || wf(t) ? null : qw(l, c, s); a.push(g) } null !== l && (l.hasOwnProperty("class") && (t.flags |= 8), l.hasOwnProperty("style") && (t.flags |= 16)), t.initialInputs = a, t.inputs = l, t.outputs = u }(e, n, i) } function Gf(e, t, n) { const r = n.directiveStart, o = n.directiveEnd, i = n.index, s = function Tv() { return O.lFrame.currentDirectiveIndex }(); try { un(i); for (let a = r; a < o; a++) { const l = e.data[a], u = t[a]; Ns(a), (null !== l.hostBindings || 0 !== l.hostVars || null !== l.hostAttrs) && Bw(l, u) } } finally { un(-1), Ns(s) } } function Bw(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function $a(e, t, n) { t.componentOffset = n, (e.components ?? (e.components = [])).push(t.index) } function $w(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; it(t) && (n[""] = e) } } function Gw(e, t, n, r, o) { e.data[r] = o; const i = o.factory || (o.factory = ln(o.type)), s = new br(i, it(o), _); e.blueprint[r] = s, n[r] = s, function kw(e, t, n, r, o) { const i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; null === s && (s = e.hostBindingOpCodes = []); const a = ~t.index; (function Lw(e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(s) != a && s.push(a), s.push(n, r, i) } }(e, t, r, Vr(e, n, o.hostVars, P), o) } function _t(e, t, n, r, o, i) { const s = qe(e, t); !function Ua(e, t, n, r, o, i, s) { if (null == i) e.removeAttribute(t, o, n); else { const a = null == s ? N(i) : s(i, r || "", o); e.setAttribute(t, o, a, n) } }(t[L], s, i, e.value, n, r, o) } function Ww(e, t, n, r, o, i) { const s = i[t]; if (null !== s) { const a = r.setInput; for (let l = 0; l < s.length;) { const u = s[l++], c = s[l++], d = s[l++]; null !== a ? r.setInput(n, d, u, c) : n[c] = d } } } function qw(e, t, n) { let r = null, o = 0; for (; o < n.length;) { const i = n[o]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; if (e.hasOwnProperty(i)) { null === r && (r = []); const s = e[i]; for (let a = 0; a < s.length; a += 2)if (s[a] === t) { r.push(i, s[a + 1], n[o + 1]); break } } o += 2 } else o += 2; else o += 4 } return r } function zf(e, t, n, r) { return [e, !0, !1, t, null, 0, r, n, null, null] } function Qw(e, t) { const n = je(t, e); if (No(n)) { const r = n[E]; 48 & n[R] ? oi(r, n, r.template, n[ue]) : n[an] > 0 && Ga(n) } } function Ga(e) { for (let r = oa(e); null !== r; r = ia(r))for (let o = xe; o < r.length; o++) { const i = r[o]; if (No(i)) if (512 & i[R]) { const s = i[E]; oi(s, i, s.template, i[ue]) } else i[an] > 0 && Ga(i) } const n = e[E].components; if (null !== n) for (let r = 0; r < n.length; r++) { const o = je(n[r], e); No(o) && o[an] > 0 && Ga(o) } } function Kw(e, t) { const n = je(t, e), r = n[E]; (function Xw(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) })(r, n), ka(r, n, n[ue]) } function ii(e, t) { return e[vr] ? e[Ec][rt] = t : e[vr] = t, e[Ec] = t, t } function si(e) { for (; e;) { e[R] |= 32; const t = xr(e); if (av(e) && !t) return e; e = t } return null } function ai(e, t, n, r = !0) { const o = t[Io]; o.begin && o.begin(); try { oi(e, t, e.template, n) } catch (s) { throw r && Yf(t, s), s } finally { o.end && o.end() } } function za(e, t, n) { Os(0), t(e, n) } function Wf(e) { return e[wn] || (e[wn] = []) } function qf(e) { return e.cleanup || (e.cleanup = []) } function Yf(e, t) { const n = e[Mo], r = n ? n.get(Hn, null) : null; r && r.handleError(t) } function Wa(e, t, n, r, o) { for (let i = 0; i < n.length;) { const s = n[i++], a = n[i++], l = t[s], u = e.data[s]; null !== u.setInput ? u.setInput(l, o, r, a) : l[a] = o } } function li(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? i = a : 1 == i ? o = gs(o, a) : 2 == i && (r = gs(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function ui(e, t, n, r, o = !1) { for (; null !== n;) { const i = t[n.index]; if (null !== i && r.push(ve(i)), ot(i)) for (let a = xe; a < i.length; a++) { const l = i[a], u = l[E].firstChild; null !== u && ui(l[E], l, u, r) } const s = n.type; if (8 & s) ui(e, t, n.child, r); else if (32 & s) { const a = ra(n, t); let l; for (; l = a();)r.push(l) } else if (16 & s) { const a = $d(t, n); if (Array.isArray(a)) r.push(...a); else { const l = xr(t[Ee]); ui(l[E], l, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } class Br { get rootNodes() { const t = this._lView, n = t[E]; return ui(n, t, n.firstChild, []) } constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[ue] } set context(t) { this._lView[ue] = t } get destroyed() { return 128 == (128 & this._lView[R]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[ae]; if (ot(t)) { const n = t[Ao], r = n ? n.indexOf(this) : -1; r > -1 && (la(t, r), jo(n, r)) } this._attachedToViewContainer = !1 } Od(this._lView[E], this._lView) } onDestroy(t) { !function jf(e, t, n, r) { const o = Wf(t); null === n ? o.push(r) : (o.push(n), e.firstCreatePass && qf(e).push(r, o.length - 1)) }(this._lView[E], this._lView, null, t) } markForCheck() { si(this._cdRefInjectingView || this._lView) } detach() { this._lView[R] &= -65 } reattach() { this._lView[R] |= 64 } detectChanges() { ai(this._lView[E], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new C(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function V_(e, t) { Or(e, t, t[L], 2, null, null) }(this._lView[E], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new C(902, !1); this._appRef = t } } class Jw extends Br { constructor(t) { super(t), this._view = t } detectChanges() { const t = this._view; ai(t[E], t, t[ue], !1) } checkNoChanges() { } get context() { return null } } class Qf extends ei { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = q(t); return new jr(n, this.ngModule) } } function Kf(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } class tE { constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { r = wo(r); const o = this.injector.get(t, Aa, r); return o !== Aa || n === Aa ? o : this.parentInjector.get(t, n, r) } } class jr extends mf { get inputs() { return Kf(this.componentDef.inputs) } get outputs() { return Kf(this.componentDef.outputs) } constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function iw(e) { return e.map(ow).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } create(t, n, r, o) { let i = (o = o || this.ngModule) instanceof Vn ? o : o?.injector; i && null !== this.componentDef.getStandaloneInjector && (i = this.componentDef.getStandaloneInjector(i) || i); const s = i ? new tE(t, i) : t, a = s.get(Df, null); if (null === a) throw new C(407, !1); const l = s.get(VC, null), u = a.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", d = r ? function Fw(e, t, n) { return e.selectRootElement(t, n === mt.ShadowDom) }(u, r, this.componentDef.encapsulation) : aa(u, c, function eE(e) { const t = e.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(c)), f = this.componentDef.onPush ? 288 : 272, h = ja(0, null, null, 1, 0, null, null, null, null, null), p = ri(null, h, null, f, null, null, a, u, l, s, null); let g, D; Ps(p); try { const v = this.componentDef; let b, m = null; v.findHostDirectiveDefs ? (b = [], m = new Map, v.findHostDirectiveDefs(v, b, m), b.push(v)) : b = [v]; const M = function rE(e, t) { const n = e[E], r = ne; return e[r] = t, Gn(n, r, 2, "#host", null) }(p, d), G = function oE(e, t, n, r, o, i, s, a) { const l = o[E]; !function iE(e, t, n, r) { for (const o of e) t.mergedAttrs = Mr(t.mergedAttrs, o.hostAttrs); null !== t.mergedAttrs && (li(t, t.mergedAttrs, !0), null !== n && zd(r, n, t)) }(r, e, t, s); const u = i.createRenderer(t, n), c = ri(o, Bf(n), null, n.onPush ? 32 : 16, o[e.index], e, i, u, a || null, null, null); return l.firstCreatePass && $a(l, e, r.length - 1), ii(o, c), o[e.index] = c }(M, d, v, b, p, a, u); D = Oc(h, ne), d && function aE(e, t, n, r) { if (r) Vs(e, n, ["ng-version", BC.full]); else { const { attrs: o, classes: i } = function sw(e) { const t = [], n = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && t.push(i, e[++r]) : 8 === o && n.push(i); else { if (!at(o)) break; o = i } r++ } return { attrs: t, classes: n } }(t.selectors[0]); o && Vs(e, n, o), i && i.length > 0 && Gd(e, n, i.join(" ")) } }(u, v, d, r), void 0 !== n && function lE(e, t, n) { const r = e.projection = []; for (let o = 0; o < t.length; o++) { const i = n[o]; r.push(null != i ? Array.from(i) : null) } }(D, this.ngContentSelectors, n), g = function sE(e, t, n, r, o, i) { const s = _e(), a = o[E], l = qe(s, o); Uf(a, o, s, n, null, r); for (let c = 0; c < n.length; c++)Me(cn(o, a, s.directiveStart + c, s), o); Gf(a, o, s), l && Me(l, o); const u = cn(o, a, s.directiveStart + s.componentOffset, s); if (e[ue] = o[ue] = u, null !== i) for (const c of i) c(u, t); return La(a, s, e), u }(G, v, b, m, p, [uE]), ka(h, p, null) } finally { Rs() } return new nE(this.componentType, g, jn(D, p), p, D) } } class nE extends xC { constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.instance = n, this.hostView = this.changeDetectorRef = new Jw(o), this.componentType = t } setInput(t, n) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[t])) { const i = this._rootLView; Wa(i[E], i, o, t, n), si(je(this._tNode.index, i)) } } get injector() { return new Tn(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } function uE() { const e = _e(); xo(y()[E], e) } function Z(e) { let t = function Xf(e) { return Object.getPrototypeOf(e.prototype).constructor }(e.type), n = !0; const r = [e]; for (; t;) { let o; if (it(e)) o = t.\u0275cmp || t.\u0275dir; else { if (t.\u0275cmp) throw new C(903, !1); o = t.\u0275dir } if (o) { if (n) { r.push(o); const s = e; s.inputs = qa(e.inputs), s.declaredInputs = qa(e.declaredInputs), s.outputs = qa(e.outputs); const a = o.hostBindings; a && hE(e, a); const l = o.viewQuery, u = o.contentQueries; if (l && dE(e, l), u && fE(e, u), ps(e.inputs, o.inputs), ps(e.declaredInputs, o.declaredInputs), ps(e.outputs, o.outputs), it(o) && o.data.animation) { const c = e.data; c.animation = (c.animation || []).concat(o.data.animation) } } const i = o.features; if (i) for (let s = 0; s < i.length; s++) { const a = i[s]; a && a.ngInherit && a(e), a === Z && (n = !1) } } t = Object.getPrototypeOf(t) } !function cE(e) { let t = 0, n = null; for (let r = e.length - 1; r >= 0; r--) { const o = e[r]; o.hostVars = t += o.hostVars, o.hostAttrs = Mr(o.hostAttrs, n = Mr(n, o.hostAttrs)) } }(r) } function qa(e) { return e === Tt ? {} : e === U ? [] : e } function dE(e, t) { const n = e.viewQuery; e.viewQuery = n ? (r, o) => { t(r, o), n(r, o) } : t } function fE(e, t) { const n = e.contentQueries; e.contentQueries = n ? (r, o, i) => { t(r, o, i), n(r, o, i) } : t } function hE(e, t) { const n = e.hostBindings; e.hostBindings = n ? (r, o) => { t(r, o), n(r, o) } : t } function ci(e) { return !!Za(e) && (Array.isArray(e) || !(e instanceof Map) && Symbol.iterator in e) } function Za(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function Ie(e, t, n) { return !Object.is(e[t], n) && (e[t] = n, !0) } function Vt(e, t, n, r) { const o = y(); return Ie(o, Sn(), t) && (H(), _t(ie(), o, e, t, n, r)), Vt } function Ya(e, t, n, r, o, i, s, a) { const l = y(), u = H(), c = e + ne, d = u.firstCreatePass ? function EE(e, t, n, r, o, i, s, a, l) { const u = t.consts, c = Gn(t, e, 4, s || null, Zt(u, a)); Ha(t, n, c, Zt(u, l)), xo(t, c); const d = c.tView = ja(2, c, r, o, i, t.directiveRegistry, t.pipeRegistry, null, t.schemas, u); return null !== t.queries && (t.queries.template(t, c), d.queries = t.queries.embeddedTView(c)), c }(c, u, l, t, n, r, o, i, s) : u.data[c]; Dt(d, !1); const f = l[L].createComment(""); qo(u, l, f, d), Me(f, l), ii(l, l[c] = zf(f, l, f, d)), To(d) && Va(u, l, d), null != s && Ba(l, d, a) } function Qa(e) { return function In(e, t) { return e[t] }(function Iv() { return O.lFrame.contextLView }(), ne + e) } function er(e, t, n) { const r = y(); return Ie(r, Sn(), t) && function Ye(e, t, n, r, o, i, s, a) { const l = qe(t, n); let c, u = t.inputs; !a && null != u && (c = u[r]) ? (Wa(e, n, c, r, o), wr(t) && function Pw(e, t) { const n = je(t, e); 16 & n[R] || (n[R] |= 32) }(n, t.index)) : 3 & t.type && (r = function Ow(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, t.value || "", r) : o, i.setProperty(l, r, o)) }(H(), ie(), r, e, t, r[L], n, !1), er } function Ka(e, t, n, r, o) { const s = o ? "class" : "style"; Wa(e, n, t.inputs[s], s, r) } function V(e, t, n, r) { const o = y(), i = H(), s = ne + e, a = o[L], l = i.firstCreatePass ? function ME(e, t, n, r, o, i) { const s = t.consts, l = Gn(t, e, 2, r, Zt(s, o)); return Ha(t, n, l, Zt(s, i)), null !== l.attrs && li(l, l.attrs, !1), null !== l.mergedAttrs && li(l, l.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, l), l }(s, i, o, t, n, r) : i.data[s], u = o[s] = aa(a, t, function Lv() { return O.lFrame.currentNamespace }()), c = To(l); return Dt(l, !0), zd(a, u, l), 32 != (32 & l.flags) && qo(i, o, u, l), 0 === function vv() { return O.lFrame.elementDepthCount }() && Me(u, o), function _v() { O.lFrame.elementDepthCount++ }(), c && (Va(i, o, l), La(i, l, o)), null !== r && Ba(o, l), V } function B() { let e = _e(); Ts() ? function Fs() { O.lFrame.isParent = !1 }() : (e = e.parent, Dt(e, !1)); const t = e; !function Cv() { O.lFrame.elementDepthCount-- }(); const n = H(); return n.firstCreatePass && (xo(n, e), Is(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function Hv(e) { return 0 != (8 & e.flags) }(t) && Ka(n, t, y(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function $v(e) { return 0 != (16 & e.flags) }(t) && Ka(n, t, y(), t.stylesWithoutHost, !1), B } function Se(e, t, n, r) { return V(e, t, n, r), B(), Se } function fi(e) { return !!e && "function" == typeof e.then } const hh = function fh(e) { return !!e && "function" == typeof e.subscribe }; function lt(e, t, n, r) { const o = y(), i = H(), s = _e(); return function gh(e, t, n, r, o, i, s) { const a = To(r), u = e.firstCreatePass && qf(e), c = t[ue], d = Wf(t); let f = !0; if (3 & r.type || s) { const g = qe(r, t), D = s ? s(g) : g, v = d.length, b = s ? M => s(ve(M[r.index])) : r.index; let m = null; if (!s && a && (m = function AE(e, t, n, r) { const o = e.cleanup; if (null != o) for (let i = 0; i < o.length - 1; i += 2) { const s = o[i]; if (s === n && o[i + 1] === r) { const a = t[wn], l = o[i + 2]; return a.length > l ? a[l] : null } "string" == typeof s && (i += 2) } return null }(e, t, o, r.index)), null !== m) (m.__ngLastListenerFn__ || m).__ngNextListenerFn__ = i, m.__ngLastListenerFn__ = i, f = !1; else { i = yh(r, t, c, i, !1); const M = n.listen(D, o, i); d.push(i, M), u && u.push(o, b, v, v + 1) } } else i = yh(r, t, c, i, !1); const h = r.outputs; let p; if (f && null !== h && (p = h[o])) { const g = p.length; if (g) for (let D = 0; D < g; D += 2) { const G = t[p[D]][p[D + 1]].subscribe(i), fe = d.length; d.push(i, G), u && u.push(o, r.index, fe, -(fe + 1)) } } }(i, o, o[L], s, e, t, r), lt } function mh(e, t, n, r) { try { return Xe(6, t, n), !1 !== n(r) } catch (o) { return Yf(e, o), !1 } finally { Xe(7, t, n) } } function yh(e, t, n, r, o) { return function i(s) { if (s === Function) return r; si(e.componentOffset > -1 ? je(e.index, t) : t); let l = mh(t, n, r, s), u = i.__ngNextListenerFn__; for (; u;)l = mh(t, n, u, s) && l, u = u.__ngNextListenerFn__; return o && !1 === l && (s.preventDefault(), s.returnValue = !1), l } } function hi(e, t) { return e << 17 | t << 2 } function Kt(e) { return e >> 17 & 32767 } function tl(e) { return 2 | e } function mn(e) { return (131068 & e) >> 2 } function nl(e, t) { return -131069 & e | t << 2 } function rl(e) { return 1 | e } function Sh(e, t, n, r, o) { const i = e[n + 1], s = null === t; let a = r ? Kt(i) : mn(i), l = !1; for (; 0 !== a && (!1 === l || s);) { const c = e[a + 1]; VE(e[a], t) && (l = !0, e[a + 1] = r ? rl(c) : tl(c)), a = r ? Kt(c) : mn(c) } l && (e[n + 1] = r ? tl(i) : rl(i)) } function VE(e, t) { return null === e || null == t || (Array.isArray(e) ? e[1] : e) === t || !(!Array.isArray(e) || "string" != typeof t) && Pn(e, t) >= 0 } function pi(e, t) { return function ut(e, t, n, r) { const o = y(), i = H(), s = function Pt(e) { const t = O.lFrame, n = t.bindingIndex; return t.bindingIndex = t.bindingIndex + e, n }(2); i.firstUpdatePass && function kh(e, t, n, r) { const o = e.data; if (null === o[n + 1]) { const i = o[Pe()], s = function Rh(e, t) { return t >= e.expandoStartIndex }(e, n); (function jh(e, t) { return 0 != (e.flags & (t ? 8 : 16)) })(i, r) && null === t && !s && (t = !1), t = function qE(e, t, n, r) { const o = function xs(e) { const t = O.lFrame.currentDirectiveIndex; return -1 === t ? null : e[t] }(e); let i = r ? t.residualClasses : t.residualStyles; if (null === o) 0 === (r ? t.classBindings : t.styleBindings) && (n = $r(n = ol(null, e, t, n, r), t.attrs, r), i = null); else { const s = t.directiveStylingLast; if (-1 === s || e[s] !== o) if (n = ol(o, e, t, n, r), null === i) { let l = function ZE(e, t, n) { const r = n ? t.classBindings : t.styleBindings; if (0 !== mn(r)) return e[Kt(r)] }(e, t, r); void 0 !== l && Array.isArray(l) && (l = ol(null, e, t, l[1], r), l = $r(l, t.attrs, r), function YE(e, t, n, r) { e[Kt(n ? t.classBindings : t.styleBindings)] = r }(e, t, r, l)) } else i = function QE(e, t, n) { let r; const o = t.directiveEnd; for (let i = 1 + t.directiveStylingLast; i < o; i++)r = $r(r, e[i].hostAttrs, n); return $r(r, t.attrs, n) }(e, t, r) } return void 0 !== i && (r ? t.residualClasses = i : t.residualStyles = i), n }(o, i, t, r), function kE(e, t, n, r, o, i) { let s = i ? t.classBindings : t.styleBindings, a = Kt(s), l = mn(s); e[r] = n; let c, u = !1; if (Array.isArray(n) ? (c = n[1], (null === c || Pn(n, c) > 0) && (u = !0)) : c = n, o) if (0 !== l) { const f = Kt(e[a + 1]); e[r + 1] = hi(f, a), 0 !== f && (e[f + 1] = nl(e[f + 1], r)), e[a + 1] = function PE(e, t) { return 131071 & e | t << 17 }(e[a + 1], r) } else e[r + 1] = hi(a, 0), 0 !== a && (e[a + 1] = nl(e[a + 1], r)), a = r; else e[r + 1] = hi(l, 0), 0 === a ? a = r : e[l + 1] = nl(e[l + 1], r), l = r; u && (e[r + 1] = tl(e[r + 1])), Sh(e, c, r, !0), Sh(e, c, r, !1), function LE(e, t, n, r, o) { const i = o ? e.residualClasses : e.residualStyles; null != i && "string" == typeof t && Pn(i, t) >= 0 && (n[r + 1] = rl(n[r + 1])) }(t, c, e, r, i), s = hi(a, l), i ? t.classBindings = s : t.styleBindings = s }(o, i, t, n, s, r) } }(i, e, s, r), t !== P && Ie(o, s, t) && function Vh(e, t, n, r, o, i, s, a) { if (!(3 & t.type)) return; const l = e.data, u = l[a + 1], c = function RE(e) { return 1 == (1 & e) }(u) ? Bh(l, t, n, o, mn(u), s) : void 0; gi(c) || (gi(i) || function OE(e) { return 2 == (2 & e) }(u) && (i = Bh(l, null, n, o, a, s)), function Z_(e, t, n, r, o) { if (t) o ? e.addClass(n, r) : e.removeClass(n, r); else { let i = -1 === r.indexOf("-") ? void 0 : He.DashCase; null == o ? e.removeStyle(n, r, i) : ("string" == typeof o && o.endsWith("!important") && (o = o.slice(0, -10), i |= He.Important), e.setStyle(n, r, o, i)) } }(r, s, function Fo(e, t) { return ve(t[e]) }(Pe(), n), o, i)) }(i, i.data[Pe()], o, o[L], e, o[s + 1] = function eb(e, t) { return null == e || "" === e || ("string" == typeof t ? e += t : "object" == typeof e && (e = K(function Yt(e) { return e instanceof Qd ? e.changingThisBreaksApplicationSecurity : e }(e)))), e }(t, n), r, s) }(e, t, null, !0), pi } function ol(e, t, n, r, o) { let i = null; const s = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < s && (i = t[a], r = $r(r, i.hostAttrs, o), i !== e);)a++; return null !== e && (n.directiveStylingLast = a), r } function $r(e, t, n) { const r = n ? 1 : 2; let o = -1; if (null !== t) for (let i = 0; i < t.length; i++) { const s = t[i]; "number" == typeof s ? o = s : o === r && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), Ze(e, s, !!n || t[++i])) } return void 0 === e ? null : e } function Bh(e, t, n, r, o, i) { const s = null === t; let a; for (; o > 0;) { const l = e[o], u = Array.isArray(l), c = u ? l[1] : l, d = null === c; let f = n[o + 1]; f === P && (f = d ? U : void 0); let h = d ? qs(f, r) : c === r ? f : void 0; if (u && !gi(h) && (h = qs(l, r)), gi(h) && (a = h, s)) return a; const p = e[o + 1]; o = s ? Kt(p) : mn(p) } if (null !== t) { let l = i ? t.residualClasses : t.residualStyles; null != l && (a = qs(l, r)) } return a } function gi(e) { return void 0 !== e } function Y(e, t = "") { const n = y(), r = H(), o = e + ne, i = r.firstCreatePass ? Gn(r, o, 1, t, null) : r.data[o], s = n[o] = function sa(e, t) { return e.createText(t) }(n[L], t); qo(r, n, s, i), Dt(i, !1) } const rr = "en-US"; let up = rr; function ll(e, t, n, r, o) { if (e = S(e), Array.isArray(e)) for (let i = 0; i < e.length; i++)ll(e[i], t, n, r, o); else { const i = H(), s = y(); let a = hn(e) ? e : S(e.provide), l = gf(e); const u = _e(), c = 1048575 & u.providerIndexes, d = u.directiveStart, f = u.providerIndexes >> 20; if (hn(e) || !e.multi) { const h = new br(l, o, _), p = cl(a, t, o ? c : c + f, d); -1 === p ? ($s(Vo(u, s), i, a), ul(i, e, t.length), t.push(a), u.directiveStart++, u.directiveEnd++, o && (u.providerIndexes += 1048576), n.push(h), s.push(h)) : (n[p] = h, s[p] = h) } else { const h = cl(a, t, c + f, d), p = cl(a, t, c, c + f), D = p >= 0 && n[p]; if (o && !D || !o && !(h >= 0 && n[h])) { $s(Vo(u, s), i, a); const v = function DM(e, t, n, r, o) { const i = new br(e, n, _); return i.multi = [], i.index = t, i.componentProviders = 0, Pp(i, o, r && !n), i }(o ? yM : mM, n.length, o, r, l); !o && D && (n[p].providerFactory = v), ul(i, e, t.length, 0), t.push(a), u.directiveStart++, u.directiveEnd++, o && (u.providerIndexes += 1048576), n.push(v), s.push(v) } else ul(i, e, h > -1 ? h : p, Pp(n[o ? p : h], l, !o && r)); !o && r && D && n[p].componentProviders++ } } } function ul(e, t, n, r) { const o = hn(t), i = function MC(e) { return !!e.useClass }(t); if (o || i) { const l = (i ? S(t.useClass) : t).prototype.ngOnDestroy; if (l) { const u = e.destroyHooks || (e.destroyHooks = []); if (!o && t.multi) { const c = u.indexOf(n); -1 === c ? u.push(n, [r, l]) : u[c + 1].push(r, l) } else u.push(n, l) } } } function Pp(e, t, n) { return n && e.componentProviders++, e.multi.push(t) - 1 } function cl(e, t, n, r) { for (let o = n; o < r; o++)if (t[o] === e) return o; return -1 } function mM(e, t, n, r) { return dl(this.multi, []) } function yM(e, t, n, r) { const o = this.multi; let i; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = cn(n, n[E], this.providerFactory.index, r); i = a.slice(0, s), dl(o, i); for (let l = s; l < a.length; l++)i.push(a[l]) } else i = [], dl(o, i); return i } function dl(e, t) { for (let n = 0; n < e.length; n++)t.push((0, e[n])()); return t } function re(e, t = []) { return n => { n.providersResolver = (r, o) => function gM(e, t, n) { const r = H(); if (r.firstCreatePass) { const o = it(e); ll(n, r.data, r.blueprint, o, !0), ll(t, r.data, r.blueprint, o, !1) } }(r, o ? o(e) : e, t) } } class or { } class vM { } class Rp extends or { constructor(t, n) { super(), this._parent = n, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new Qf(this); const r = function ze(e, t) { const n = e[vc] || null; if (!n && !0 === t) throw new Error(`Type ${K(e)} does not have '\u0275mod' property.`); return n }(t); this._bootstrapComponents = function kt(e) { return e instanceof Function ? e() : e }(r.bootstrap), this._r3Injector = Ff(t, n, [{ provide: or, useValue: this }, { provide: ei, useValue: this.componentFactoryResolver }], K(t), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(t) } get injector() { return this._r3Injector } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class fl extends vM { constructor(t) { super(), this.moduleType = t } create(t) { return new Rp(this.moduleType, t) } } function pl(e, t, n, r) { return function Up(e, t, n, r, o, i) { const s = t + n; return Ie(e, s, o) ? function Ct(e, t, n) { return e[t] = n }(e, s + 1, i ? r.call(i, o) : r(o)) : function Zr(e, t) { const n = e[t]; return n === P ? void 0 : n }(e, s + 1) }(y(), function Oe() { const e = O.lFrame; let t = e.bindingRootIndex; return -1 === t && (t = e.bindingRootIndex = e.tView.bindingStartIndex), t }(), e, t, n, r) } function gl(e) { return t => { setTimeout(e, void 0, t) } } const Ae = class ZM extends ss { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && "object" == typeof t) { const l = t; o = l.next?.bind(l), i = l.error?.bind(l), s = l.complete?.bind(l) } this.__isAsync && (i = gl(i), o && (o = gl(o)), s && (s = gl(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof pt && t.add(a), a } }; let Bt = (() => { class e { } return e.__NG_ELEMENT_ID__ = XM, e })(); const QM = Bt, KM = class extends QM { constructor(t, n, r) { super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(t, n) { const r = this._declarationTContainer.tView, o = ri(this._declarationLView, r, t, 16, null, r.declTNode, null, null, null, null, n || null); o[_r] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[yt]; return null !== s && (o[yt] = s.createEmbeddedView(r)), ka(r, o, t), new Br(o) } }; function XM() { return function _i(e, t) { return 4 & e.type ? new KM(t, e, jn(e, t)) : null }(_e(), y()) } let bt = (() => { class e { } return e.__NG_ELEMENT_ID__ = JM, e })(); function JM() { return function Qp(e, t) { let n; const r = t[e.index]; if (ot(r)) n = r; else { let o; if (8 & e.type) o = ve(r); else { const i = t[L]; o = i.createComment(""); const s = qe(e, t); fn(i, Wo(i, s), o, function z_(e, t) { return e.nextSibling(t) }(i, s), !1) } t[e.index] = n = zf(r, t, o, e), ii(t, n) } return new Zp(n, e, t) }(_e(), y()) } const e0 = bt, Zp = class extends e0 { constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return jn(this._hostTNode, this._hostLView) } get injector() { return new Tn(this._hostTNode, this._hostLView) } get parentInjector() { const t = Hs(this._hostTNode, this._hostLView); if (Kc(t)) { const n = ko(t, this._hostLView), r = Ro(t); return new Tn(n[E].data[r + 8], n) } return new Tn(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const n = Yp(this._lContainer); return null !== n && n[t] || null } get length() { return this._lContainer.length - xe } createEmbeddedView(t, n, r) { let o, i; "number" == typeof r ? o = r : null != r && (o = r.index, i = r.injector); const s = t.createEmbeddedView(n || {}, i); return this.insert(s, o), s } createComponent(t, n, r, o, i) { const s = t && !function Sr(e) { return "function" == typeof e }(t); let a; if (s) a = n; else { const d = n || {}; a = d.index, r = d.injector, o = d.projectableNodes, i = d.environmentInjector || d.ngModuleRef } const l = s ? t : new jr(q(t)), u = r || this.parentInjector; if (!i && null == l.ngModule) { const f = (s ? u : this.parentInjector).get(Vn, null); f && (i = f) } const c = l.create(u, o, void 0, i); return this.insert(c.hostView, a), c } insert(t, n) { const r = t._lView, o = r[E]; if (function Dv(e) { return ot(e[ae]) }(r)) { const c = this.indexOf(t); if (-1 !== c) this.detach(c); else { const d = r[ae], f = new Zp(d, d[we], d[ae]); f.detach(f.indexOf(t)) } } const i = this._adjustIndex(n), s = this._lContainer; !function j_(e, t, n, r) { const o = xe + r, i = n.length; r > 0 && (n[o - 1][rt] = t), r < i - xe ? (t[rt] = n[o], ud(n, xe + r, t)) : (n.push(t), t[rt] = null), t[ae] = n; const s = t[_r]; null !== s && n !== s && function H_(e, t) { const n = e[Mn]; t[Ee] !== t[ae][ae][Ee] && (e[Mc] = !0), null === n ? e[Mn] = [t] : n.push(t) }(s, t); const a = t[yt]; null !== a && a.insertView(e), t[R] |= 64 }(o, r, s, i); const a = da(i, s), l = r[L], u = Wo(l, s[So]); return null !== u && function L_(e, t, n, r, o, i) { r[Nt] = o, r[we] = t, Or(e, r, n, 1, o, i) }(o, s[we], l, r, u, a), t.attachToViewContainerRef(), ud(yl(s), i, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { const n = Yp(this._lContainer); return null !== n ? n.indexOf(t) : -1 } remove(t) { const n = this._adjustIndex(t, -1), r = la(this._lContainer, n); r && (jo(yl(this._lContainer), n), Od(r[E], r)) } detach(t) { const n = this._adjustIndex(t, -1), r = la(this._lContainer, n); return r && null != jo(yl(this._lContainer), n) ? new Br(r) : null } _adjustIndex(t, n = 0) { return t ?? this.length + n } }; function Yp(e) { return e[Ao] } function yl(e) { return e[Ao] || (e[Ao] = []) } function wi(...e) { } const _g = new F("Application Initializer"); let Ei = (() => { class e { constructor(n) { this.appInits = n, this.resolve = wi, this.reject = wi, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, o) => { this.resolve = r, this.reject = o }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let o = 0; o < this.appInits.length; o++) { const i = this.appInits[o](); if (fi(i)) n.push(i); else if (hh(i)) { const s = new Promise((a, l) => { i.subscribe({ complete: a, error: l }) }); n.push(s) } } Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), 0 === n.length && r(), this.initialized = !0 } } return e.\u0275fac = function (n) { return new (n || e)($(_g, 8)) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Kr = new F("AppId", { providedIn: "root", factory: function Cg() { return `${Sl()}${Sl()}${Sl()}` } }); function Sl() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const wg = new F("Platform Initializer"), Eg = new F("Platform ID", { providedIn: "platform", factory: () => "unknown" }), jt = new F("LocaleId", { providedIn: "root", factory: () => function Dc(e, t = T.Default) { return $(e, wo(t)) }(jt, T.Optional | T.SkipSelf) || function x0() { return typeof $localize < "u" && $localize.locale || rr }() }), L0 = (() => Promise.resolve(0))(); function Al(e) { typeof Zone > "u" ? L0.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class Te { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Ae(!1), this.onMicrotaskEmpty = new Ae(!1), this.onStable = new Ae(!1), this.onError = new Ae(!1), typeof Zone > "u") throw new C(908, !1); Zone.assertZonePatched(); const o = this; o._nesting = 0, o._outer = o._inner = Zone.current, Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function V0() { let e = te.requestAnimationFrame, t = te.cancelAnimationFrame; if (typeof Zone < "u" && e && t) { const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n); const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function H0(e) { const t = () => { !function j0(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(te, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, Fl(e), e.isCheckStableRunning = !0, Tl(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), Fl(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { try { return Ig(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), Sg(e) } }, onInvoke: (n, r, o, i, s, a, l) => { try { return Ig(e), n.invoke(o, i, s, a, l) } finally { e.shouldCoalesceRunChangeDetection && t(), Sg(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, Fl(e), Tl(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Te.isInAngularZone()) throw new C(909, !1) } static assertNotInAngularZone() { if (Te.isInAngularZone()) throw new C(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, B0, wi, wi); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const B0 = {}; function Tl(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function Fl(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function Ig(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function Sg(e) { e._nesting--, Tl(e) } class $0 { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Ae, this.onMicrotaskEmpty = new Ae, this.onStable = new Ae, this.onError = new Ae } run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } } const Ag = new F(""), bi = new F(""); let Ol, Nl = (() => { class e { constructor(n, r, o) { this._ngZone = n, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, Ol || (function U0(e) { Ol = e }(o), o.addToWindow(r)), this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Te.assertNotInAngularZone(), Al(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Al(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, o) { let i = -1; r && r > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== i), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: i, updateCb: o }) } whenStable(n, r, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(n) { this.registry.registerApplication(n, this) } unregisterApplication(n) { this.registry.unregisterApplication(n) } findProviders(n, r, o) { return [] } } return e.\u0275fac = function (n) { return new (n || e)($(Te), $(xl), $(bi)) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac }), e })(), xl = (() => { class e { constructor() { this._applications = new Map } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return Ol?.findTestabilityInTree(this, n, r) ?? null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const Ht = !1; let Xt = null; const Tg = new F("AllowMultipleToken"), Pl = new F("PlatformDestroyListeners"), G0 = new F("appBootstrapListener"); function Ng(e, t, n = []) { const r = `Platform: ${t}`, o = new F(r); return (i = []) => { let s = Rl(); if (!s || s.injector.get(Tg, !1)) { const a = [...n, ...i, { provide: o, useValue: !0 }]; e ? e(a) : function q0(e) { if (Xt && !Xt.get(Tg, !1)) throw new C(400, !1); Xt = e; const t = e.get(Og); (function Fg(e) { const t = e.get(wg, null); t && t.forEach(n => n()) })(e) }(function xg(e = [], t) { return Qt.create({ name: t, providers: [{ provide: ba, useValue: "platform" }, { provide: Pl, useValue: new Set([() => Xt = null]) }, ...e] }) }(a, r)) } return function Y0(e) { const t = Rl(); if (!t) throw new C(401, !1); return t }() } } function Rl() { return Xt?.get(Og) ?? null } let Og = (() => { class e { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const o = function Rg(e, t) { let n; return n = "noop" === e ? new $0 : ("zone.js" === e ? void 0 : e) || new Te(t), n }(r?.ngZone, function Pg(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!e || !e.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!e || !e.ngZoneRunCoalescing) || !1 } }(r)), i = [{ provide: Te, useValue: o }]; return o.run(() => { const s = Qt.create({ providers: i, parent: this.injector, name: n.moduleType.name }), a = n.create(s), l = a.injector.get(Hn, null); if (!l) throw new C(402, !1); return o.runOutsideAngular(() => { const u = o.onError.subscribe({ next: c => { l.handleError(c) } }); a.onDestroy(() => { Mi(this._modules, a), u.unsubscribe() }) }), function kg(e, t, n) { try { const r = n(); return fi(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(l, o, () => { const u = a.injector.get(Ei); return u.runInitializers(), u.donePromise.then(() => (function cp(e) { Qe(e, "Expected localeId to be defined"), "string" == typeof e && (up = e.toLowerCase().replace(/_/g, "-")) }(a.injector.get(jt, rr) || rr), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(n, r = []) { const o = Lg({}, r); return function z0(e, t, n) { const r = new fl(n); return Promise.resolve(r) }(0, 0, n).then(i => this.bootstrapModuleFactory(i, o)) } _moduleDoBootstrap(n) { const r = n.injector.get(kl); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(o => r.bootstrap(o)); else { if (!n.instance.ngDoBootstrap) throw new C(-403, !1); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new C(404, !1); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(Pl, null); n && (n.forEach(r => r()), n.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (n) { return new (n || e)($(Qt)) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); function Lg(e, t) { return Array.isArray(t) ? t.reduce(Lg, e) : { ...e, ...t } } let kl = (() => { class e { get destroyed() { return this._destroyed } get injector() { return this._injector } constructor(n, r, o) { this._zone = n, this._injector = r, this._exceptionHandler = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const i = new Ne(a => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { a.next(this._stable), a.complete() }) }), s = new Ne(a => { let l; this._zone.runOutsideAngular(() => { l = this._zone.onStable.subscribe(() => { Te.assertNotInAngularZone(), Al(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, a.next(!0)) }) }) }); const u = this._zone.onUnstable.subscribe(() => { Te.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { a.next(!1) })) }); return () => { l.unsubscribe(), u.unsubscribe() } }); this.isStable = VD(i, s.pipe(function BD(e = {}) { const { connector: t = (() => new ss), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s, a, l, u = 0, c = !1, d = !1; const f = () => { a?.unsubscribe(), a = void 0 }, h = () => { f(), s = l = void 0, c = d = !1 }, p = () => { const g = s; h(), g?.unsubscribe() }; return fr((g, D) => { u++, !d && !c && f(); const v = l = l ?? t(); D.add(() => { u--, 0 === u && !d && !c && (a = hs(p, o)) }), v.subscribe(D), !s && u > 0 && (s = new dr({ next: b => v.next(b), error: b => { d = !0, f(), a = hs(h, n, b), v.error(b) }, complete: () => { c = !0, f(), a = hs(h, r), v.complete() } }), It(g).subscribe(s)) })(i) } }())) } bootstrap(n, r) { const o = n instanceof mf; if (!this._injector.get(Ei).done) { !o && function Dr(e) { const t = q(e) || Ce(e) || Be(e); return null !== t && t.standalone }(n); throw new C(405, Ht) } let s; s = o ? n : this._injector.get(ei).resolveComponentFactory(n), this.componentTypes.push(s.componentType); const a = function W0(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(or), u = s.create(Qt.NULL, [], r || s.selector, a), c = u.location.nativeElement, d = u.injector.get(Ag, null); return d?.registerApplication(c), u.onDestroy(() => { this.detachView(u.hostView), Mi(this.components, u), d?.unregisterApplication(c) }), this._loadComponent(u), u } tick() { if (this._runningTick) throw new C(101, !1); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; Mi(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n); const r = this._injector.get(G0, []); r.push(...this._bootstrapListeners), r.forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => Mi(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new C(406, !1); const n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return e.\u0275fac = function (n) { return new (n || e)($(Te), $(Vn), $(Hn)) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function Mi(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } let jg = (() => { class e { } return e.__NG_ELEMENT_ID__ = K0, e })(); function K0(e) { return function X0(e, t, n) { if (wr(e) && !n) { const r = je(e.index, t); return new Br(r, r) } return 47 & e.type ? new Br(t[Ee], t) : null }(_e(), y(), 16 == (16 & e)) } class Ug { constructor() { } supports(t) { return ci(t) } create(t) { return new oI(t) } } const rI = (e, t) => t; class oI { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || rI } forEachItem(t) { let n; for (n = this._itHead; null !== n; n = n._next)t(n) } forEachOperation(t) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { const s = !r || n && n.currentIndex < zg(r, o, i) ? n : r, a = zg(s, o, i), l = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, null == s.previousIndex) o++; else { i || (i = []); const u = a - o, c = l - o; if (u != c) { for (let f = 0; f < u; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; c <= p && p < u && (i[f] = h + 1) } i[s.previousIndex] = c - u } } a !== l && t(s, a, l) } } forEachPreviousItem(t) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachMovedItem(t) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } forEachIdentityChange(t) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)t(n) } diff(t) { if (null == t && (t = []), !ci(t)) throw new C(900, !1); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let o, i, s, n = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)i = t[a], s = this._trackByFn(a, i), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)) : (n = this._mismatch(n, i, s, a), r = !0), n = n._next } else o = 0, function _E(e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[Symbol.iterator](); let r; for (; !(r = n.next()).done;)t(r.value) } }(t, a => { s = this._trackByFn(o, a), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, s, o), r = !0), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, n, r, o) { let i; return null === t ? i = this._itTail : (i = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, i, o)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, i, o)) : t = this._addAfter(new iI(n, r), i, o), t } _verifyReinsertion(t, n, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? t = this._reinsertAfter(i, t._prev, o) : t.currentIndex != o && (t.currentIndex = o, this._addToMoves(t, o)), t } _truncate(t) { for (; null !== t;) { const n = t._next; this._addToRemovals(this._unlink(t)), t = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const o = t._prevRemoved, i = t._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(t, n, r), this._addToMoves(t, r), t } _moveAfter(t, n, r) { return this._unlink(t), this._insertAfter(t, n, r), this._addToMoves(t, r), t } _addAfter(t, n, r) { return this._insertAfter(t, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, n, r) { const o = null === n ? this._itHead : n._next; return t._next = o, t._prev = n, null === o ? this._itTail = t : o._prev = t, null === n ? this._itHead = t : n._next = t, null === this._linkedRecords && (this._linkedRecords = new Gg), this._linkedRecords.put(t), t.currentIndex = r, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const n = t._prev, r = t._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, t } _addToMoves(t, n) { return t.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Gg), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, n) { return t.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class iI { constructor(t, n) { this.item = t, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class sI { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, t)) return r; return null } remove(t) { const n = t._prevDup, r = t._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class Gg { constructor() { this.map = new Map } put(t) { const n = t.trackById; let r = this.map.get(n); r || (r = new sI, this.map.set(n, r)), r.add(t) } get(t, n) { const o = this.map.get(t); return o ? o.get(t, n) : null } remove(t) { const n = t.trackById; return this.map.get(n).remove(t) && this.map.delete(n), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function zg(e, t, n) { const r = e.previousIndex; if (null === r) return r; let o = 0; return n && r < n.length && (o = n[r]), r + t + o } class Wg { constructor() { } supports(t) { return t instanceof Map || Za(t) } create() { return new aI } } class aI { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let n; for (n = this._mapHead; null !== n; n = n._next)t(n) } forEachPreviousItem(t) { let n; for (n = this._previousMapHead; null !== n; n = n._nextPrevious)t(n) } forEachChangedItem(t) { let n; for (n = this._changesHead; null !== n; n = n._nextChanged)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } diff(t) { if (t) { if (!(t instanceof Map || Za(t))) throw new C(900, !1) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let n = this._mapHead; if (this._appendAfter = null, this._forEach(t, (r, o) => { if (n && n.key === o) this._maybeAddToChanges(n, r), this._appendAfter = n, n = n._next; else { const i = this._getOrCreateRecordForKey(o, r); n = this._insertBeforeOrAppend(n, i) } }), n) { n._prev && (n._prev._next = null), this._removalsHead = n; for (let r = n; null !== r; r = r._nextRemoved)r === this._mapHead && (this._mapHead = null), this._records.delete(r.key), r._nextRemoved = r._next, r.previousValue = r.currentValue, r.currentValue = null, r._prev = null, r._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, n) { if (t) { const r = t._prev; return n._next = t, n._prev = r, t._prev = n, r && (r._next = n), t === this._mapHead && (this._mapHead = n), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = n, n._prev = this._appendAfter) : this._mapHead = n, this._appendAfter = n, null } _getOrCreateRecordForKey(t, n) { if (this._records.has(t)) { const o = this._records.get(t); this._maybeAddToChanges(o, n); const i = o._prev, s = o._next; return i && (i._next = s), s && (s._prev = i), o._next = null, o._prev = null, o } const r = new lI(t); return this._records.set(t, r), r.currentValue = n, this._addToAdditions(r), r } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, n) { Object.is(n, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = n, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, n) { t instanceof Map ? t.forEach(n) : Object.keys(t).forEach(r => n(t[r], r)) } } class lI { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function qg() { return new Ai([new Ug]) } let Ai = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || qg()), deps: [[e, new Uo, new $o]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (null != r) return r; throw new C(901, !1) } } return e.\u0275prov = ee({ token: e, providedIn: "root", factory: qg }), e })(); function Zg() { return new Xr([new Wg]) } let Xr = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || Zg()), deps: [[e, new Uo, new $o]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (r) return r; throw new C(901, !1) } } return e.\u0275prov = ee({ token: e, providedIn: "root", factory: Zg }), e })(); const dI = Ng(null, "core", []); let fI = (() => { class e { constructor(n) { } } return e.\u0275fac = function (n) { return new (n || e)($(kl)) }, e.\u0275mod = qt({ type: e }), e.\u0275inj = St({}), e })(); function Hl(e) { return "boolean" == typeof e ? e : null != e && "false" !== e } let $l = null; function ar() { return $l } class gI { } const $t = new F("DocumentToken"), Xl = /\s+/, om = []; let Jl = (() => { class e { constructor(n, r, o, i) { this._iterableDiffers = n, this._keyValueDiffers = r, this._ngEl = o, this._renderer = i, this.initialClasses = om, this.stateMap = new Map } set klass(n) { this.initialClasses = null != n ? n.trim().split(Xl) : om } set ngClass(n) { this.rawClass = "string" == typeof n ? n.trim().split(Xl) : n } ngDoCheck() { for (const r of this.initialClasses) this._updateState(r, !0); const n = this.rawClass; if (Array.isArray(n) || n instanceof Set) for (const r of n) this._updateState(r, !0); else if (null != n) for (const r of Object.keys(n)) this._updateState(r, Boolean(n[r])); this._applyStateDiff() } _updateState(n, r) { const o = this.stateMap.get(n); void 0 !== o ? (o.enabled !== r && (o.changed = !0, o.enabled = r), o.touched = !0) : this.stateMap.set(n, { enabled: r, changed: !0, touched: !0 }) } _applyStateDiff() { for (const n of this.stateMap) { const r = n[0], o = n[1]; o.changed ? (this._toggleClass(r, o.enabled), o.changed = !1) : o.touched || (o.enabled && this._toggleClass(r, !1), this.stateMap.delete(r)), o.touched = !1 } } _toggleClass(n, r) { (n = n.trim()).length > 0 && n.split(Xl).forEach(o => { r ? this._renderer.addClass(this._ngEl.nativeElement, o) : this._renderer.removeClass(this._ngEl.nativeElement, o) }) } } return e.\u0275fac = function (n) { return new (n || e)(_(Ai), _(Xr), _(st), _(pn)) }, e.\u0275dir = x({ type: e, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, standalone: !0 }), e })(), eu = (() => { class e { constructor(n, r) { this._viewContainer = n, this._context = new iS, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(n) { this._context.$implicit = this._context.ngIf = n, this._updateView() } set ngIfThen(n) { lm("ngIfThen", n), this._thenTemplateRef = n, this._thenViewRef = null, this._updateView() } set ngIfElse(n) { lm("ngIfElse", n), this._elseTemplateRef = n, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(n, r) { return !0 } } return e.\u0275fac = function (n) { return new (n || e)(_(bt), _(Bt)) }, e.\u0275dir = x({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }), e })(); class iS { constructor() { this.$implicit = null, this.ngIf = null } } function lm(e, t) { if (t && !t.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${K(t)}'.`) } let FS = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = qt({ type: e }), e.\u0275inj = St({}), e })(); class lA extends gI { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class au extends lA { static makeCurrent() { !function pI(e) { $l || ($l = e) }(new au) } onAndCancel(t, n, r) { return t.addEventListener(n, r, !1), () => { t.removeEventListener(n, r, !1) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = function uA() { return no = no || document.querySelector("base"), no ? no.getAttribute("href") : null }(); return null == n ? null : function cA(e) { ji = ji || document.createElement("a"), ji.setAttribute("href", e); const t = ji.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { no = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return function eS(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [o, i] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null }(document.cookie, t) } } let ji, no = null; const ym = new F("TRANSITION_ID"), fA = [{ provide: _g, useFactory: function dA(e, t, n) { return () => { n.get(Ei).donePromise.then(() => { const r = ar(), o = t.querySelectorAll(`style[ng-transition="${e}"]`); for (let i = 0; i < o.length; i++)r.remove(o[i]) }) } }, deps: [ym, $t, Qt], multi: !0 }]; let pA = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac }), e })(); const Hi = new F("EventManagerPlugins"); let $i = (() => { class e { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(o => { o.manager = this }), this._plugins = n.slice().reverse() } addEventListener(n, r, o) { return this._findPluginFor(r).addEventListener(n, r, o) } addGlobalEventListener(n, r, o) { return this._findPluginFor(r).addGlobalEventListener(n, r, o) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const o = this._plugins; for (let i = 0; i < o.length; i++) { const s = o[i]; if (s.supports(n)) return this._eventNameToPlugin.set(n, s), s } throw new Error(`No event manager plugin found for event ${n}`) } } return e.\u0275fac = function (n) { return new (n || e)($(Hi), $(Te)) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac }), e })(); class Dm { constructor(t) { this._doc = t } addGlobalEventListener(t, n, r) { const o = ar().getGlobalEventTarget(this._doc, t); if (!o) throw new Error(`Unsupported event target ${o} for event ${n}`); return this.addEventListener(o, n, r) } } let vm = (() => { class e { constructor() { this.usageCount = new Map } addStyles(n) { for (const r of n) 1 === this.changeUsageCount(r, 1) && this.onStyleAdded(r) } removeStyles(n) { for (const r of n) 0 === this.changeUsageCount(r, -1) && this.onStyleRemoved(r) } onStyleRemoved(n) { } onStyleAdded(n) { } getAllStyles() { return this.usageCount.keys() } changeUsageCount(n, r) { const o = this.usageCount; let i = o.get(n) ?? 0; return i += r, i > 0 ? o.set(n, i) : o.delete(n), i } ngOnDestroy() { for (const n of this.getAllStyles()) this.onStyleRemoved(n); this.usageCount.clear() } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac }), e })(), ro = (() => { class e extends vm { constructor(n) { super(), this.doc = n, this.styleRef = new Map, this.hostNodes = new Set, this.resetHostNodes() } onStyleAdded(n) { for (const r of this.hostNodes) this.addStyleToHost(r, n) } onStyleRemoved(n) { const r = this.styleRef; r.get(n)?.forEach(i => i.remove()), r.delete(n) } ngOnDestroy() { super.ngOnDestroy(), this.styleRef.clear(), this.resetHostNodes() } addHost(n) { this.hostNodes.add(n); for (const r of this.getAllStyles()) this.addStyleToHost(n, r) } removeHost(n) { this.hostNodes.delete(n) } addStyleToHost(n, r) { const o = this.doc.createElement("style"); o.textContent = r, n.appendChild(o); const i = this.styleRef.get(r); i ? i.push(o) : this.styleRef.set(r, [o]) } resetHostNodes() { const n = this.hostNodes; n.clear(), n.add(this.doc.head) } } return e.\u0275fac = function (n) { return new (n || e)($($t)) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac }), e })(); const lu = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, uu = /%COMP%/g, wm = new F("RemoveStylesOnCompDestory", { providedIn: "root", factory: () => !1 }); function Em(e, t) { return t.flat(100).map(n => n.replace(uu, e)) } function bm(e) { return t => { if ("__ngUnwrap__" === t) return e; !1 === e(t) && (t.preventDefault(), t.returnValue = !1) } } let cu = (() => { class e { constructor(n, r, o, i) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.removeStylesOnCompDestory = i, this.rendererByCompId = new Map, this.defaultRenderer = new du(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; const o = this.getOrCreateRenderer(n, r); return o instanceof Sm ? o.applyToHost(n) : o instanceof fu && o.applyStyles(), o } getOrCreateRenderer(n, r) { const o = this.rendererByCompId; let i = o.get(r.id); if (!i) { const s = this.eventManager, a = this.sharedStylesHost, l = this.removeStylesOnCompDestory; switch (r.encapsulation) { case mt.Emulated: i = new Sm(s, a, r, this.appId, l); break; case mt.ShadowDom: return new CA(s, a, n, r); default: i = new fu(s, a, r, l) }i.onDestroy = () => o.delete(r.id), o.set(r.id, i) } return i } ngOnDestroy() { this.rendererByCompId.clear() } begin() { } end() { } } return e.\u0275fac = function (n) { return new (n || e)($($i), $(ro), $(Kr), $(wm)) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac }), e })(); class du { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? document.createElementNS(lu[n] || n, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, n) { (Im(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (Im(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? document.querySelector(t) : t; if (!r) throw new Error(`The selector "${t}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; const i = lu[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const o = lu[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (He.DashCase | He.Important) ? t.style.setProperty(n, r, o & He.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & He.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, n, bm(r)) : this.eventManager.addEventListener(t, n, bm(r)) } } function Im(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class CA extends du { constructor(t, n, r, o) { super(t), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const i = Em(o.id, o.styles); for (const s of i) { const a = document.createElement("style"); a.textContent = s, this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class fu extends du { constructor(t, n, r, o, i = r.id) { super(t), this.sharedStylesHost = n, this.removeStylesOnCompDestory = o, this.rendererUsageCount = 0, this.styles = Em(i, r.styles) } applyStyles() { this.sharedStylesHost.addStyles(this.styles), this.rendererUsageCount++ } destroy() { this.removeStylesOnCompDestory && (this.sharedStylesHost.removeStyles(this.styles), this.rendererUsageCount--, 0 === this.rendererUsageCount && this.onDestroy?.()) } } class Sm extends fu { constructor(t, n, r, o, i) { const s = o + "-" + r.id; super(t, n, r, i, s), this.contentAttr = function DA(e) { return "_ngcontent-%COMP%".replace(uu, e) }(s), this.hostAttr = function vA(e) { return "_nghost-%COMP%".replace(uu, e) }(s) } applyToHost(t) { this.applyStyles(), this.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } let wA = (() => { class e extends Dm { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o) { return n.addEventListener(r, o, !1), () => this.removeEventListener(n, r, o) } removeEventListener(n, r, o) { return n.removeEventListener(r, o) } } return e.\u0275fac = function (n) { return new (n || e)($($t)) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac }), e })(); const Am = ["alt", "control", "meta", "shift"], EA = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, bA = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let MA = (() => { class e extends Dm { constructor(n) { super(n) } supports(n) { return null != e.parseEventName(n) } addEventListener(n, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => ar().onAndCancel(n, i.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), Am.forEach(u => { const c = r.indexOf(u); c > -1 && (r.splice(c, 1), s += u + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const l = {}; return l.domEventName = o, l.fullKey = s, l } static matchEventFullKeyCode(n, r) { let o = EA[n.key] || n.key, i = ""; return r.indexOf("code.") > -1 && (o = n.code, i = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), Am.forEach(s => { s !== o && (0, bA[s])(n) && (i += s + ".") }), i += o, i === r) } static eventCallback(n, r, o) { return i => { e.matchEventFullKeyCode(i, n) && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return e.\u0275fac = function (n) { return new (n || e)($($t)) }, e.\u0275prov = ee({ token: e, factory: e.\u0275fac }), e })(); const TA = Ng(dI, "browser", [{ provide: Eg, useValue: "browser" }, { provide: wg, useValue: function IA() { au.makeCurrent() }, multi: !0 }, { provide: $t, useFactory: function AA() { return function J_(e) { ga = e }(document), document }, deps: [] }]), Nm = new F(""), xm = [{ provide: bi, useClass: class hA { addToWindow(t) { te.getAngularTestability = (r, o = !0) => { const i = t.findTestabilityInTree(r, o); if (null == i) throw new Error("Could not find testability for element."); return i }, te.getAllAngularTestabilities = () => t.getAllTestabilities(), te.getAllAngularRootElements = () => t.getAllRootElements(), te.frameworkStabilizers || (te.frameworkStabilizers = []), te.frameworkStabilizers.push(r => { const o = te.getAllAngularTestabilities(); let i = o.length, s = !1; const a = function (l) { s = s || l, i--, 0 == i && r(s) }; o.forEach(function (l) { l.whenStable(a) }) }) } findTestabilityInTree(t, n, r) { return null == n ? null : t.getTestability(n) ?? (r ? ar().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null) } }, deps: [] }, { provide: Ag, useClass: Nl, deps: [Te, xl, bi] }, { provide: Nl, useClass: Nl, deps: [Te, xl, bi] }], Om = [{ provide: ba, useValue: "root" }, { provide: Hn, useFactory: function SA() { return new Hn }, deps: [] }, { provide: Hi, useClass: wA, multi: !0, deps: [$t, Te, Eg] }, { provide: Hi, useClass: MA, multi: !0, deps: [$t] }, { provide: cu, useClass: cu, deps: [$i, ro, Kr, wm] }, { provide: Df, useExisting: cu }, { provide: vm, useExisting: ro }, { provide: ro, useClass: ro, deps: [$t] }, { provide: $i, useClass: $i, deps: [Hi, Te] }, { provide: class RS { }, useClass: pA, deps: [] }, []]; let FA = (() => { class e { constructor(n) { } static withServerTransition(n) { return { ngModule: e, providers: [{ provide: Kr, useValue: n.appId }, { provide: ym, useExisting: Kr }, fA] } } } return e.\u0275fac = function (n) { return new (n || e)($(Nm, 12)) }, e.\u0275mod = qt({ type: e }), e.\u0275inj = St({ providers: [...Om, ...xm], imports: [FS, fI] }), e })(); typeof window < "u" && window; let VA = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = sn({ type: e, selectors: [["app-nav"]], decls: 17, vars: 0, consts: [[1, "navbar", "navbar-expand-lg"], [1, "container", "pt-3"], ["href", "#", 1, "navbar-brand"], ["src", "./assets/images/logo.svg", "alt", "logo"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#navbarNav", "aria-controls", "navbarNav", "aria-expanded", "false", "aria-label", "Toggle navigation", 1, "navbar-toggler"], [1, "navbar-toggler-icon"], ["id", "navbarNav", 1, "collapse", "navbar-collapse"], [1, "navbar-nav", "ms-auto", "mb-2", "mb-lg-0"], [1, "nav-item"], ["aria-current", "page", "href", "#", 1, "nav-link", "active"], ["href", "#", 1, "nav-link"]], template: function (r, o) { 1 & r && (V(0, "nav", 0)(1, "div", 1)(2, "a", 2), Se(3, "img", 3), B(), V(4, "button", 4), Se(5, "span", 5), B(), V(6, "div", 6)(7, "ul", 7)(8, "li", 8)(9, "a", 9), Y(10, "Features"), B()(), V(11, "li", 8)(12, "a", 10), Y(13, "Team"), B()(), V(14, "li", 8)(15, "a", 10), Y(16, "Sign In"), B()()()()()()) }, styles: [".navbar[_ngcontent-%COMP%]   .navbar-toggler[_ngcontent-%COMP%]{color:#fff;font-size:25px;border-color:#fff}"] }) } return e })(); const { isArray: BA } = Array, { getPrototypeOf: jA, prototype: HA, keys: $A } = Object; const { isArray: zA } = Array; function ZA(e, t) { return e.reduce((n, r, o) => (n[r] = t[o], n), {}) } function YA(...e) { const t = function TD(e) { return oe(fs(e)) ? e.pop() : void 0 }(e), { args: n, keys: r } = function UA(e) { if (1 === e.length) { const t = e[0]; if (BA(t)) return { args: t, keys: null }; if (function GA(e) { return e && "object" == typeof e && jA(e) === HA }(t)) { const n = $A(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } }(e), o = new Ne(i => { const { length: s } = n; if (!s) return void i.complete(); const a = new Array(s); let l = s, u = s; for (let c = 0; c < s; c++) { let d = !1; It(n[c]).subscribe(hr(i, f => { d || (d = !0, u--), a[c] = f }, () => l--, void 0, () => { (!l || !d) && (u || i.next(r ? ZA(r, a) : a), i.complete()) })) } }); return t ? o.pipe(function qA(e) { return as(t => function WA(e, t) { return zA(t) ? e(...t) : e(t) }(e, t)) }(t)) : o } let km = (() => { class e { constructor(n, r) { this._renderer = n, this._elementRef = r, this.onChange = o => { }, this.onTouched = () => { } } setProperty(n, r) { this._renderer.setProperty(this._elementRef.nativeElement, n, r) } registerOnTouched(n) { this.onTouched = n } registerOnChange(n) { this.onChange = n } setDisabledState(n) { this.setProperty("disabled", n) } } return e.\u0275fac = function (n) { return new (n || e)(_(pn), _(st)) }, e.\u0275dir = x({ type: e }), e })(), vn = (() => { class e extends km { } return e.\u0275fac = function () { let t; return function (r) { return (t || (t = be(e)))(r || e) } }(), e.\u0275dir = x({ type: e, features: [Z] }), e })(); const Mt = new F("NgValueAccessor"), KA = { provide: Mt, useExisting: X(() => oo), multi: !0 }, JA = new F("CompositionEventMode"); let oo = (() => { class e extends km { constructor(n, r, o) { super(n, r), this._compositionMode = o, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function XA() { const e = ar() ? ar().getUserAgent() : ""; return /android (\d+)/.test(e.toLowerCase()) }()) } writeValue(n) { this.setProperty("value", n ?? "") } _handleInput(n) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(n) } _compositionStart() { this._composing = !0 } _compositionEnd(n) { this._composing = !1, this._compositionMode && this.onChange(n) } } return e.\u0275fac = function (n) { return new (n || e)(_(pn), _(st), _(JA, 8)) }, e.\u0275dir = x({ type: e, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (n, r) { 1 & n && lt("input", function (i) { return r._handleInput(i.target.value) })("blur", function () { return r.onTouched() })("compositionstart", function () { return r._compositionStart() })("compositionend", function (i) { return r._compositionEnd(i.target.value) }) }, features: [re([KA]), Z] }), e })(); const eT = !1; function en(e) { return null == e || ("string" == typeof e || Array.isArray(e)) && 0 === e.length } const Fe = new F("NgValidators"), tn = new F("NgAsyncValidators"); function Hm(e) { return en(e.value) ? { required: !0 } : null } function Ui(e) { return null } function qm(e) { return null != e } function Zm(e) { const t = fi(e) ? cc(e) : e; if (eT && !hh(t)) { let n = "Expected async validator to return Promise or Observable."; throw "object" == typeof e && (n += " Are you using a synchronous validator where an async validator is expected?"), new C(-1101, n) } return t } function Ym(e) { let t = {}; return e.forEach(n => { t = null != n ? { ...t, ...n } : t }), 0 === Object.keys(t).length ? null : t } function Qm(e, t) { return t.map(n => n(e)) } function Km(e) { return e.map(t => function nT(e) { return !e.validate }(t) ? t : n => t.validate(n)) } function gu(e) { return null != e ? function Xm(e) { if (!e) return null; const t = e.filter(qm); return 0 == t.length ? null : function (n) { return Ym(Qm(n, t)) } }(Km(e)) : null } function mu(e) { return null != e ? function Jm(e) { if (!e) return null; const t = e.filter(qm); return 0 == t.length ? null : function (n) { return YA(Qm(n, t).map(Zm)).pipe(as(Ym)) } }(Km(e)) : null } function ey(e, t) { return null === e ? [t] : Array.isArray(e) ? [...e, t] : [e, t] } function yu(e) { return e ? Array.isArray(e) ? e : [e] : [] } function Gi(e, t) { return Array.isArray(e) ? e.includes(t) : e === t } function ry(e, t) { const n = yu(t); return yu(e).forEach(o => { Gi(n, o) || n.push(o) }), n } function oy(e, t) { return yu(t).filter(n => !Gi(e, n)) } class iy { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = gu(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = mu(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t) { this.control && this.control.reset(t) } hasError(t, n) { return !!this.control && this.control.hasError(t, n) } getError(t, n) { return this.control ? this.control.getError(t, n) : null } } class Le extends iy { get formDirective() { return null } get path() { return null } } class nn extends iy { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class sy { constructor(t) { this._cd = t } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } } let Du = (() => { class e extends sy { constructor(n) { super(n) } } return e.\u0275fac = function (n) { return new (n || e)(_(nn, 2)) }, e.\u0275dir = x({ type: e, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (n, r) { 2 & n && pi("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending) }, features: [Z] }), e })(), vu = (() => { class e extends sy { constructor(n) { super(n) } } return e.\u0275fac = function (n) { return new (n || e)(_(Le, 10)) }, e.\u0275dir = x({ type: e, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (n, r) { 2 & n && pi("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending)("ng-submitted", r.isSubmitted) }, features: [Z] }), e })(); function ay(e, t) { return e ? `with name: '${t}'` : `at index: ${t}` } const wu = !1, io = "VALID", Wi = "INVALID", lr = "PENDING", so = "DISABLED"; function Eu(e) { return (qi(e) ? e.validators : e) || null } function bu(e, t) { return (qi(t) ? t.asyncValidators : e) || null } function qi(e) { return null != e && !Array.isArray(e) && "object" == typeof e } class cy { constructor(t, n) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._assignValidators(t), this._assignAsyncValidators(n) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === io } get invalid() { return this.status === Wi } get pending() { return this.status == lr } get disabled() { return this.status === so } get enabled() { return this.status !== so } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._assignValidators(t) } setAsyncValidators(t) { this._assignAsyncValidators(t) } addValidators(t) { this.setValidators(ry(t, this._rawValidators)) } addAsyncValidators(t) { this.setAsyncValidators(ry(t, this._rawAsyncValidators)) } removeValidators(t) { this.setValidators(oy(t, this._rawValidators)) } removeAsyncValidators(t) { this.setAsyncValidators(oy(t, this._rawAsyncValidators)) } hasValidator(t) { return Gi(this._rawValidators, t) } hasAsyncValidator(t) { return Gi(this._rawAsyncValidators, t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(n => { n.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(n => { n.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = lr, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const n = this._parentMarkedDirty(t.onlySelf); this.status = so, this.errors = null, this._forEachChild(r => { r.disable({ ...t, onlySelf: !0 }) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...t, skipPristineCheck: n }), this._onDisabledChange.forEach(r => r(!0)) } enable(t = {}) { const n = this._parentMarkedDirty(t.onlySelf); this.status = io, this._forEachChild(r => { r.enable({ ...t, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors({ ...t, skipPristineCheck: n }), this._onDisabledChange.forEach(r => r(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } getRawValue() { return this.value } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === io || this.status === lr) && this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(n => n._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? so : io } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = lr, this._hasOwnPendingAsyncValidator = !0; const n = Zm(this.asyncValidator(this)); this._asyncValidationSubscription = n.subscribe(r => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(r, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, n = {}) { this.errors = t, this._updateControlsErrors(!1 !== n.emitEvent) } get(t) { let n = t; return null == n || (Array.isArray(n) || (n = n.split(".")), 0 === n.length) ? null : n.reduce((r, o) => r && r._find(o), this) } getError(t, n) { const r = n ? this.get(n) : this; return r && r.errors ? r.errors[t] : null } hasError(t, n) { return !!this.getError(t, n) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new Ae, this.statusChanges = new Ae } _calculateStatus() { return this._allControlsDisabled() ? so : this.errors ? Wi : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(lr) ? lr : this._anyControlsHaveStatus(Wi) ? Wi : io } _anyControlsHaveStatus(t) { return this._anyControls(n => n.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { qi(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(t) { return null } _assignValidators(t) { this._rawValidators = Array.isArray(t) ? t.slice() : t, this._composedValidatorFn = function uT(e) { return Array.isArray(e) ? gu(e) : e || null }(this._rawValidators) } _assignAsyncValidators(t) { this._rawAsyncValidators = Array.isArray(t) ? t.slice() : t, this._composedAsyncValidatorFn = function cT(e) { return Array.isArray(e) ? mu(e) : e || null }(this._rawAsyncValidators) } } class Mu extends cy { constructor(t, n, r) { super(Eu(n), bu(r, n)), this.controls = t, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(t, n) { return this.controls[t] ? this.controls[t] : (this.controls[t] = n, n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange), n) } addControl(t, n, r = {}) { this.registerControl(t, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } removeControl(t, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } setControl(t, n, r = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], n && this.registerControl(t, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, n = {}) { (function uy(e, t, n) { e._forEachChild((r, o) => { if (void 0 === n[o]) throw new C(1002, wu ? function lT(e, t) { return `Must supply a value for form control ${ay(e, t)}` }(t, o) : "") }) })(this, !0, t), Object.keys(t).forEach(r => { (function ly(e, t, n) { const r = e.controls; if (!(t ? Object.keys(r) : r).length) throw new C(1e3, wu ? function sT(e) { return `\n    There are no form controls registered with this ${e ? "group" : "array"} yet. If you're using ngModel,\n    you may want to check next tick (e.g. use setTimeout).\n  ` }(t) : ""); if (!r[n]) throw new C(1001, wu ? function aT(e, t) { return `Cannot find form control ${ay(e, t)}` }(t, n) : "") })(this, !0, r), this.controls[r].setValue(t[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n) } patchValue(t, n = {}) { null != t && (Object.keys(t).forEach(r => { const o = this.controls[r]; o && o.patchValue(t[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n)) } reset(t = {}, n = {}) { this._forEachChild((r, o) => { r.reset(t[o], { onlySelf: !0, emitEvent: n.emitEvent }) }), this._updatePristine(n), this._updateTouched(n), this.updateValueAndValidity(n) } getRawValue() { return this._reduceChildren({}, (t, n, r) => (t[r] = n.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (n, r) => !!r._syncPendingControls() || n); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _forEachChild(t) { Object.keys(this.controls).forEach(n => { const r = this.controls[n]; r && t(r, n) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const [n, r] of Object.entries(this.controls)) if (this.contains(n) && t(r)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, (n, r, o) => ((r.enabled || this.disabled) && (n[o] = r.value), n)) } _reduceChildren(t, n) { let r = t; return this._forEachChild((o, i) => { r = n(r, o, i) }), r } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(t) { return this.controls.hasOwnProperty(t) ? this.controls[t] : null } } const ur = new F("CallSetDisabledState", { providedIn: "root", factory: () => Zi }), Zi = "always"; function ao(e, t, n = Zi) { Iu(e, t), t.valueAccessor.writeValue(e.value), (e.disabled || "always" === n) && t.valueAccessor.setDisabledState?.(e.disabled), function hT(e, t) { t.valueAccessor.registerOnChange(n => { e._pendingValue = n, e._pendingChange = !0, e._pendingDirty = !0, "change" === e.updateOn && dy(e, t) }) }(e, t), function gT(e, t) { const n = (r, o) => { t.valueAccessor.writeValue(r), o && t.viewToModelUpdate(r) }; e.registerOnChange(n), t._registerOnDestroy(() => { e._unregisterOnChange(n) }) }(e, t), function pT(e, t) { t.valueAccessor.registerOnTouched(() => { e._pendingTouched = !0, "blur" === e.updateOn && e._pendingChange && dy(e, t), "submit" !== e.updateOn && e.markAsTouched() }) }(e, t), function fT(e, t) { if (t.valueAccessor.setDisabledState) { const n = r => { t.valueAccessor.setDisabledState(r) }; e.registerOnDisabledChange(n), t._registerOnDestroy(() => { e._unregisterOnDisabledChange(n) }) } }(e, t) } function Ki(e, t) { e.forEach(n => { n.registerOnValidatorChange && n.registerOnValidatorChange(t) }) } function Iu(e, t) { const n = function ty(e) { return e._rawValidators }(e); null !== t.validator ? e.setValidators(ey(n, t.validator)) : "function" == typeof n && e.setValidators([n]); const r = function ny(e) { return e._rawAsyncValidators }(e); null !== t.asyncValidator ? e.setAsyncValidators(ey(r, t.asyncValidator)) : "function" == typeof r && e.setAsyncValidators([r]); const o = () => e.updateValueAndValidity(); Ki(t._rawValidators, o), Ki(t._rawAsyncValidators, o) } function dy(e, t) { e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, { emitModelToViewChange: !1 }), t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1 } const _T = { provide: Le, useExisting: X(() => uo) }, lo = (() => Promise.resolve())(); let uo = (() => { class e extends Le { constructor(n, r, o) { super(), this.callSetDisabledState = o, this.submitted = !1, this._directives = new Set, this.ngSubmit = new Ae, this.form = new Mu({}, gu(n), mu(r)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(n) { lo.then(() => { const r = this._findContainer(n.path); n.control = r.registerControl(n.name, n.control), ao(n.control, n, this.callSetDisabledState), n.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add(n) }) } getControl(n) { return this.form.get(n.path) } removeControl(n) { lo.then(() => { const r = this._findContainer(n.path); r && r.removeControl(n.name), this._directives.delete(n) }) } addFormGroup(n) { lo.then(() => { const r = this._findContainer(n.path), o = new Mu({}); (function fy(e, t) { Iu(e, t) })(o, n), r.registerControl(n.name, o), o.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(n) { lo.then(() => { const r = this._findContainer(n.path); r && r.removeControl(n.name) }) } getFormGroup(n) { return this.form.get(n.path) } updateModel(n, r) { lo.then(() => { this.form.get(n.path).setValue(r) }) } setValue(n) { this.control.setValue(n) } onSubmit(n) { return this.submitted = !0, function hy(e, t) { e._syncPendingControls(), t.forEach(n => { const r = n.control; "submit" === r.updateOn && r._pendingChange && (n.viewToModelUpdate(r._pendingValue), r._pendingChange = !1) }) }(this.form, this._directives), this.ngSubmit.emit(n), "dialog" === n?.target?.method } onReset() { this.resetForm() } resetForm(n) { this.form.reset(n), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(n) { return n.pop(), n.length ? this.form.get(n) : this.form } } return e.\u0275fac = function (n) { return new (n || e)(_(Fe, 10), _(tn, 10), _(ur, 8)) }, e.\u0275dir = x({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (n, r) { 1 & n && lt("submit", function (i) { return r.onSubmit(i) })("reset", function () { return r.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [re([_T]), Z] }), e })(); function py(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } function gy(e) { return "object" == typeof e && null !== e && 2 === Object.keys(e).length && "value" in e && "disabled" in e } const my = class extends cy { constructor(t = null, n, r) { super(Eu(n), bu(r, n)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(t), this._setUpdateStrategy(n), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), qi(n) && (n.nonNullable || n.initialValueIsDefault) && (this.defaultValue = gy(t) ? t.value : t) } setValue(t, n = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== n.emitModelToViewChange && this._onChange.forEach(r => r(this.value, !1 !== n.emitViewToModelChange)), this.updateValueAndValidity(n) } patchValue(t, n = {}) { this.setValue(t, n) } reset(t = this.defaultValue, n = {}) { this._applyFormState(t), this.markAsPristine(n), this.markAsUntouched(n), this.setValue(this.value, n), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { py(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { py(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { gy(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } }, ET = { provide: nn, useExisting: X(() => Ji) }, vy = (() => Promise.resolve())(); let Ji = (() => { class e extends nn { constructor(n, r, o, i, s, a) { super(), this._changeDetectorRef = s, this.callSetDisabledState = a, this.control = new my, this._registered = !1, this.update = new Ae, this._parent = n, this._setValidators(r), this._setAsyncValidators(o), this.valueAccessor = function Tu(e, t) { if (!t) return null; let n, r, o; return Array.isArray(t), t.forEach(i => { i.constructor === oo ? n = i : function DT(e) { return Object.getPrototypeOf(e.constructor) === vn }(i) ? r = i : o = i }), o || r || n || null }(0, i) } ngOnChanges(n) { if (this._checkForErrors(), !this._registered || "name" in n) { if (this._registered && (this._checkName(), this.formDirective)) { const r = n.name.previousValue; this.formDirective.removeControl({ name: r, path: this._getPath(r) }) } this._setUpControl() } "isDisabled" in n && this._updateDisabled(n), function Au(e, t) { if (!e.hasOwnProperty("model")) return !1; const n = e.model; return !!n.isFirstChange() || !Object.is(t, n.currentValue) }(n, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._getPath(this.name) } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(n) { this.viewModel = n, this.update.emit(n) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { ao(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(n) { vy.then(() => { this.control.setValue(n, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck() }) } _updateDisabled(n) { const r = n.isDisabled.currentValue, o = 0 !== r && Hl(r); vy.then(() => { o && !this.control.disabled ? this.control.disable() : !o && this.control.disabled && this.control.enable(), this._changeDetectorRef?.markForCheck() }) } _getPath(n) { return this._parent ? function Yi(e, t) { return [...t.path, e] }(n, this._parent) : [n] } } return e.\u0275fac = function (n) { return new (n || e)(_(Le, 9), _(Fe, 10), _(tn, 10), _(Mt, 10), _(jg, 8), _(ur, 8)) }, e.\u0275dir = x({ type: e, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [re([ET]), Z, xt] }), e })(), Fu = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275dir = x({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), e })(), Cy = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = qt({ type: e }), e.\u0275inj = St({}), e })(), _n = (() => { class e { constructor() { this._validator = Ui } ngOnChanges(n) { if (this.inputName in n) { const r = this.normalizeInput(n[this.inputName].currentValue); this._enabled = this.enabled(r), this._validator = this._enabled ? this.createValidator(r) : Ui, this._onChange && this._onChange() } } validate(n) { return this._validator(n) } registerOnValidatorChange(n) { this._onChange = n } enabled(n) { return null != n } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275dir = x({ type: e, features: [xt] }), e })(); const HT = { provide: Fe, useExisting: X(() => co), multi: !0 }; let co = (() => { class e extends _n { constructor() { super(...arguments), this.inputName = "required", this.normalizeInput = Hl, this.createValidator = n => Hm } enabled(n) { return n } } return e.\u0275fac = function () { let t; return function (r) { return (t || (t = be(e)))(r || e) } }(), e.\u0275dir = x({ type: e, selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]], hostVars: 1, hostBindings: function (n, r) { 2 & n && Vt("required", r._enabled ? "" : null) }, inputs: { required: "required" }, features: [re([HT]), Z] }), e })(); const WT = { provide: Fe, useExisting: X(() => es), multi: !0 }; let es = (() => { class e extends _n { constructor() { super(...arguments), this.inputName = "pattern", this.normalizeInput = n => n, this.createValidator = n => function Wm(e) { if (!e) return Ui; let t, n; return "string" == typeof e ? (n = "", "^" !== e.charAt(0) && (n += "^"), n += e, "$" !== e.charAt(e.length - 1) && (n += "$"), t = new RegExp(n)) : (n = e.toString(), t = e), r => { if (en(r.value)) return null; const o = r.value; return t.test(o) ? null : { pattern: { requiredPattern: n, actualValue: o } } } }(n) } } return e.\u0275fac = function () { let t; return function (r) { return (t || (t = be(e)))(r || e) } }(), e.\u0275dir = x({ type: e, selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]], hostVars: 1, hostBindings: function (n, r) { 2 & n && Vt("pattern", r._enabled ? r.pattern : null) }, inputs: { pattern: "pattern" }, features: [re([WT]), Z] }), e })(), qT = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = qt({ type: e }), e.\u0275inj = St({ imports: [Cy] }), e })(), YT = (() => { class e { static withConfig(n) { return { ngModule: e, providers: [{ provide: ur, useValue: n.callSetDisabledState ?? Zi }] } } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = qt({ type: e }), e.\u0275inj = St({ imports: [qT] }), e })(); function QT(e, t) { 1 & e && (V(0, "div", 13), Y(1, " Please check your email "), B()) } const KT = function (e) { return { dirt: e } }; let XT = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = sn({ type: e, selectors: [["app-landing"]], decls: 18, vars: 4, consts: [[1, "landing", "container", "pt-5", "d-flex", "justify-content-center", "align-items-center"], [1, "row", "d-flex", "justify-content-center", "align-items-center", "gap-3", "flex-wrap", "flex-lg-nowrap"], [1, "info", "order-lg-1", "order-2", "text-lg-start", "text-center", "col-12", "col-lg-6"], [1, "fw-bold", "lh-base"], [1, "mb-3", "d-flex", "gap-2", "flex-wrap", "flex-lg-nowrap"], [1, "mb-3", "col-12", "col-lg-8"], ["type", "email", "id", "email", "placeholder", "Enter your email...", "required", "", "ngModel", "", "name", "email", "pattern", "[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$", 1, "form-control", "text-center", "text-lg-start", "ps-4", "py-3", 3, "ngClass"], ["email", "ngModel"], ["class", "wrong ms-lg-4 text-lg-start", 4, "ngIf"], [1, "mb-3", "col-12", "col-lg-4"], ["type", "submit", 1, "btn", "btn-primary", "py-3"], [1, "image", "order-lg-2", "order-1", "col-12", "col-lg-6"], ["src", "./assets/images/illustration-1.svg", "alt", "illustration-1"], [1, "wrong", "ms-lg-4", "text-lg-start"]], template: function (r, o) { if (1 & r && (V(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "h1", 3), Y(4, "All your files in one secure location, accessible anywhere."), B(), V(5, "p"), Y(6, "Fylo stores your most important files in one secure location. Access them wherever you need, share and collaborate with friends, family, and co-workers."), B(), V(7, "form")(8, "div", 4)(9, "div", 5), Se(10, "input", 6, 7), Ya(12, QT, 2, 0, "div", 8), B(), V(13, "div", 9)(14, "button", 10), Y(15, "Get Started"), B()()()()(), V(16, "div", 11), Se(17, "img", 12), B()()()), 2 & r) { const i = Qa(11); Lr(10), er("ngClass", pl(2, KT, i.invalid && (i.dirty || i.touched))), Lr(2), er("ngIf", i.invalid && (i.dirty || i.touched)) } }, dependencies: [Jl, eu, Fu, oo, Du, vu, co, es, Ji, uo], styles: [".landing[_ngcontent-%COMP%]{min-height:calc(100vh - 72px)}.landing[_ngcontent-%COMP%]   .info[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{width:100%;background-color:var(--Bright-Blue)}.landing[_ngcontent-%COMP%]   .info[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover{opacity:80%}.form-control[_ngcontent-%COMP%]{border-color:var(--Very-Dark-Blue)}.form-control[_ngcontent-%COMP%]::placeholder{color:var(--Light-Gray);font-size:14px}.form-control[_ngcontent-%COMP%]:focus{box-shadow:none!important}.dirt[_ngcontent-%COMP%]{border-color:var(--Light-Red)}.wrong[_ngcontent-%COMP%]{color:var(--Light-Red);font-size:12px;margin-top:5px}.landing[_ngcontent-%COMP%]   .image[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{max-width:100%}"] }) } return e })(), JT = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = sn({ type: e, selectors: [["app-about-fylo"]], decls: 27, vars: 0, consts: [[1, "about", "d-flex", "justify-content-center", "align-items-center", "py-5"], [1, "container", "d-flex", "justify-content-center", "align-items-center", "gap-3", "flex-wrap", "flex-lg-nowrap"], [1, "info", "col-12", "col-lg-7", "order-lg-1", "order-2"], [1, "intro"], [1, "fw-bold", "text-lg-start", "text-center", "mb-4"], [1, "col-lg-9", "pe-lg-5"], ["href", "#", 1, "fylo-works", "text-lg-start", "text-center", "fw-bold"], ["src", "./assets/images/icon-arrow.svg", "alt", "icon-arrow"], [1, "box", "p-4", "mt-3"], ["src", "./assets/images/icon-quotes.svg", "alt", "icon-quotes", 1, "mb-2"], [1, "profile", "d-flex", "align-items-center", "gap-3"], ["src", "./assets/images/avatar-testimonial.jpg", "alt", "avater"], [1, "name"], [1, "image", "order-lg-2", "order-1", "col-12", "col-lg-5"], ["src", "./assets/images/illustration-2.svg", "alt", "illustration-2"]], template: function (r, o) { 1 & r && (V(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h1", 4), Y(5, "Stay productive, wherever you are"), B(), V(6, "div", 5)(7, "p"), Y(8, "Never let location be an issue when accessing your files. Fylo has you covered for all of your file storage needs. "), B(), V(9, "p"), Y(10, "Securely share files and folders with friends, family and colleagues for live collaboration. No email attachments required!"), B()(), V(11, "a", 6), Y(12, "See how Fylo works "), Se(13, "img", 7), B()(), V(14, "div", 8), Se(15, "img", 9), V(16, "p"), Y(17, "Fylo has improved our team productivity by an order of magnitude. Since making the switch our team has become a well-oiled collaboration machine."), B(), V(18, "div", 10), Se(19, "img", 11), V(20, "div", 12)(21, "h6"), Y(22, "Kyle Burton"), B(), V(23, "span"), Y(24, "Founder & CEO, Huddle"), B()()()()(), V(25, "div", 13), Se(26, "img", 14), B()()()) }, styles: ['.about[_ngcontent-%COMP%]{margin-top:110px;min-height:100vh;background-color:var(--Light-Grayish-Blue);position:relative}.about[_ngcontent-%COMP%]:after{content:"";position:absolute;top:-110px;background-image:url(bg-curve-desktop.7c9aeabae8006af8.svg);background-size:cover;height:110px;width:100%;z-index:-1}@media (max-width: 992px){.about[_ngcontent-%COMP%]:after{background-image:url(bg-curve-mobile.7a68fdcf05950de0.svg)}}.about[_ngcontent-%COMP%]   .image[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{max-width:100%}.fylo-works[_ngcontent-%COMP%]{color:var(--Moderate-Cyan);text-decoration:none;border-bottom:1px solid;padding-bottom:5px}.fylo-works[_ngcontent-%COMP%]:hover{opacity:70%}.box[_ngcontent-%COMP%]{background-color:#fff;width:60%;border-radius:5px;box-shadow:var(--Light-Gray) 0 5px 15px}.box[_ngcontent-%COMP%]   .profile[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{border-radius:50%;width:50px}.box[_ngcontent-%COMP%]   .profile[_ngcontent-%COMP%]   .name[_ngcontent-%COMP%]   h6[_ngcontent-%COMP%]{font-size:14px;font-weight:700;margin-bottom:0}.box[_ngcontent-%COMP%]   .profile[_ngcontent-%COMP%]   .name[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:12px}@media (max-width: 992px){.box[_ngcontent-%COMP%]{width:100%}}'] }) } return e })(); function eF(e, t) { 1 & e && (V(0, "div", 13), Y(1, " Please check your email "), B()) } const tF = function (e) { return { dirt: e } }; let nF = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = sn({ type: e, selectors: [["app-early-access"]], decls: 16, vars: 4, consts: [[1, "access", "d-flex", "justify-content-center", "align-items-center", "py-5"], [1, "container", "d-flex", "justify-content-between", "align-items-baseline", "flex-wrap", "text-center", "text-lg-start"], [1, "text", "d-flex", "flex-column", "justify-content-between", "col-12", "col-lg-6"], [1, "fw-bold", "mb-4"], [1, "col-12", "col-lg-9"], [1, "col-12", "col-lg-4"], [1, "mb-3", "d-flex", "gap-2", "flex-wrap"], [1, "mb-3", "col-12"], ["type", "email", "id", "email", "placeholder", "Enter your email...", "required", "", "ngModel", "", "name", "email", "pattern", "[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$", 1, "form-control", "text-center", "text-lg-start", "ps-4", "py-3", 3, "ngClass"], ["email", "ngModel"], ["class", "wrong ms-lg-4 text-lg-start", 4, "ngIf"], [1, "mb-3", "col-12", "col-lg-8"], ["type", "submit", 1, "btn", "btn-primary", "py-3"], [1, "wrong", "ms-lg-4", "text-lg-start"]], template: function (r, o) { if (1 & r && (V(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "h2", 3), Y(4, " Get early access today"), B(), V(5, "p", 4), Y(6, "It only takes a minute to sign up and our free starter tier is extremely generous. If you have any questions, our support team would be happy to help you."), B()(), V(7, "form", 5)(8, "div", 6)(9, "div", 7), Se(10, "input", 8, 9), Ya(12, eF, 2, 0, "div", 10), B(), V(13, "div", 11)(14, "button", 12), Y(15, "Get Started For Free"), B()()()()()()), 2 & r) { const i = Qa(11); Lr(10), er("ngClass", pl(2, tF, i.invalid && (i.dirty || i.touched))), Lr(2), er("ngIf", i.invalid && (i.dirty || i.touched)) } }, dependencies: [Jl, eu, Fu, oo, Du, vu, co, es, Ji, uo], styles: [".access[_ngcontent-%COMP%]{min-height:40vh;background-color:var(--Desaturated-Blue);color:#fff}.access[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:#fff}.dirt[_ngcontent-%COMP%]{border-color:var(--Light-Red)}.wrong[_ngcontent-%COMP%]{color:var(--Light-Gray);font-size:12px;margin-top:5px}form[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{width:100%;background-color:var(--Bright-Blue)}form[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover{background-color:var(--Light-Gray)}"] }) } return e })(), rF = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = sn({ type: e, selectors: [["app-footer-fylo"]], decls: 31, vars: 0, consts: [[1, "footer-fylo", "py-5", "d-flex", "justify-content-center", "align-items-center"], [1, "container"], ["src", "./assets/images/logo.svg", "alt", "logo", 1, ""], [1, "content", "d-flex", "justify-content-between", "flex-column", "flex-lg-row", "mt-4"], ["src", "./assets/images/icon-phone.svg", "alt", "icon-phone", 1, "me-2"], ["src", "./assets/images/icon-email.svg", "alt", "icon-phone", 1, "me-2"], [1, "social", "text-center", "text-lg-start"], [1, "fab", "fa-facebook-f"], [1, "fab", "fa-twitter"], [1, "fab", "fa-instagram"]], template: function (r, o) { 1 & r && (V(0, "div", 0)(1, "div", 1), Se(2, "img", 2), V(3, "div", 3)(4, "ul")(5, "li"), Se(6, "img", 4), Y(7, " Phone: +1-543-123-4567"), B(), V(8, "li"), Se(9, "img", 5), Y(10, "example@fylo.com"), B()(), V(11, "ul")(12, "li"), Y(13, "About Us"), B(), V(14, "li"), Y(15, "Jobs"), B(), V(16, "li"), Y(17, "Press"), B(), V(18, "li"), Y(19, "Blog"), B()(), V(20, "ul")(21, "li"), Y(22, "Contact Us"), B(), V(23, "li"), Y(24, "Terms"), B(), V(25, "li"), Y(26, "Privacy"), B()(), V(27, "div", 6), Se(28, "i", 7)(29, "i", 8)(30, "i", 9), B()()()()) }, styles: [".footer-fylo[_ngcontent-%COMP%]{min-height:60vh;background-color:var(--Very-Dark-Blue);color:#fff}.footer-fylo[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{filter:brightness(0) invert(1)}ul[_ngcontent-%COMP%]{list-style:none;padding:0}li[_ngcontent-%COMP%]{color:#fff!important;margin-bottom:10px;cursor:pointer}li[_ngcontent-%COMP%]:hover{color:var(--Bright-Blue)!important}.social[_ngcontent-%COMP%]{display:flex;justify-content:center;gap:15px}.social[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{color:var(--Blue);border:1px solid white;border-radius:50%;padding:5px;width:15px;height:15px;cursor:pointer}.social[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]:hover{color:var(--Bright-Blue);border-color:var(--Bright-Blue)}"] }) } return e })(), oF = (() => { class e { constructor() { this.title = "fylo-landing-page-with-two-column-layout" } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = sn({ type: e, selectors: [["app-root"]], decls: 5, vars: 0, template: function (r, o) { 1 & r && Se(0, "app-nav")(1, "app-landing")(2, "app-about-fylo")(3, "app-early-access")(4, "app-footer-fylo") }, dependencies: [VA, XT, JT, nF, rF] }) } return e })(), iF = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = qt({ type: e, bootstrap: [oF] }); static #n = this.\u0275inj = St({ imports: [FA, YT] }) } return e })(); TA().bootstrapModule(iF).catch(e => console.error(e)) } }, oe => { oe(oe.s = 417) }]);
